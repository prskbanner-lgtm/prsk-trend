<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>YouTube 再生数ランキング & トレンド</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --bg-body: #f8fafc;
      --bg-card: #ffffff;
      --text-main: #1e293b;
      --text-muted: #64748b;
      --primary: #3b82f6;
      --border: #e2e8f0;
      --radius-lg: 16px;
      --radius-md: 12px;
      --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background-color: var(--bg-body);
      color: var(--text-main);
      font-family: 'Inter', 'Noto Sans JP', sans-serif;
      -webkit-font-smoothing: antialiased;
      line-height: 1.5;
    }

    /* Layout Grid */
    .app-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* Header */
    header {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(12px);
      padding: 16px 20px;
      border-radius: var(--radius-lg);
      border: 1px solid rgba(255,255,255,0.5);
      box-shadow: var(--shadow-sm);
      /* Changed: fixed positioning so header doesn't shift while scrolling */
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: calc(100% - 32px);
      max-width: 1400px;
      z-index: 1000;
    }

    .brand h1 { margin: 0; font-size: 1.25rem; font-weight: 700; color: var(--text-main); }
    .brand .meta { font-size: 0.75rem; color: var(--text-muted); display: flex; gap: 8px; align-items: center; margin-top: 4px; }

    .controls { display: flex; gap: 8px; flex-wrap: wrap; }
    .controls input, .controls select, .controls button {
      background: #f1f5f9;
      border: 1px solid var(--border);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.875rem;
      color: var(--text-main);
      outline: none;
      transition: all 0.2s;
    }
    .controls input:focus, .controls select:focus {
      background: white;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(59,130,246,0.1);
    }
    .btn-primary {
      background: var(--primary) !important;
      color: white !important;
      border: none !important;
      font-weight: 600;
      cursor: pointer;
    }
    .btn-primary:hover { opacity: 0.9; }

    /* Main Grid Areas */
    .dashboard-grid {
      display: grid;
      gap: 20px;
      /* Default Mobile: Stacked */
      grid-template-columns: 1fr;
      grid-template-areas:
        "trend"
        "chart"
        "rank";
    }

    .area-trend { grid-area: trend; }
    .area-chart { grid-area: chart; }
    .area-rank  { grid-area: rank; }

    /* Cards */
    .card {
      background: var(--bg-card);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      border: 1px solid var(--border);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .card-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      font-weight: 700;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #fafafa;
    }
    .card-body { padding: 16px; flex: 1; }

    /* Trends */
    .trend-list { display: flex; flex-direction: column; gap: 12px; }
    .trend-item {
      padding: 12px;
      border-radius: var(--radius-md);
      background: #f8fafc;
      border: 1px solid var(--border);
      transition: transform 0.2s;
    }
    .trend-item:hover { transform: translateY(-2px); }
    .trend-item .label { font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px; }
    .trend-item .val { font-weight: 700; font-size: 1rem; }

    /* Chart Section */
    .chart-container { position: relative; height: 300px; width: 100%; }
    .chart-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin-top: 16px;
    }
    .metric-box {
      background: #f8fafc;
      padding: 12px;
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      text-align: center;
    }
    .metric-box .label { font-size: 0.75rem; color: var(--text-muted); }
    .metric-box .val { font-size: 1.1rem; font-weight: 700; margin-top: 4px; }

    .tabs { display: flex; gap: 4px; background: #f1f5f9; padding: 4px; border-radius: 10px; width: fit-content; margin-bottom: 16px; }
    .tabs button {
      border: none;
      background: transparent;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.8rem;
      color: var(--text-muted);
      cursor: pointer;
      font-weight: 600;
    }
    .tabs button.active { background: white; color: var(--primary); box-shadow: 0 1px 2px rgba(0,0,0,0.05); }

    /* Ranking List */
    .rank-list { display: flex; flex-direction: column; gap: 8px; max-height: 600px; overflow-y: auto; padding-right: 4px; }
    .video-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: background 0.2s;
      border: 1px solid transparent;
    }
    .video-item:hover { background: #f1f5f9; }
    .video-item.active { background: #eff6ff; border-color: #bfdbfe; }

    .rank-num { font-size: 1.1rem; font-weight: 800; color: var(--primary); width: 24px; text-align: center; flex-shrink: 0; }
    .thumb { width: 80px; height: 45px; object-fit: cover; border-radius: 6px; background: #e2e8f0; flex-shrink: 0; }
    .meta { flex: 1; min-width: 0; }
    .meta .title { font-size: 0.9rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 4px; }
    .meta .tags { display: flex; gap: 6px; flex-wrap: wrap; }
    .badge {
      font-size: 0.7rem;
      padding: 2px 8px;
      border-radius: 99px;
      background: #e2e8f0;
      color: var(--text-muted);
      white-space: nowrap;
    }
    .badge.clickable { cursor: pointer; transition: opacity 0.2s; }
    .badge.clickable:hover { opacity: 0.8; }

    /* Media Queries */

    /* Landscape Mobile & Tablet (Split View) */
    /* "Landscape mode: トレンド情報（上）→ グラフ（左）＋ランキング（右）" */
    @media (min-width: 600px) and (orientation: landscape) {
      .dashboard-grid {
        grid-template-columns: 1fr 1fr;
        grid-template-areas:
          "trend trend"
          "chart rank";
      }
      .trend-list { flex-direction: row; flex-wrap: wrap; }
      .trend-item { flex: 1 1 200px; }
      .chart-container { height: 240px; }
    }

    /* Desktop (3 Columns) */
    @media (min-width: 1200px) {
      .app-container { padding: 24px; }
      .dashboard-grid {
        grid-template-columns: 260px minmax(0, 1fr) 380px;
        grid-template-areas:
          "trend chart rank";
      }
      .trend-list { flex-direction: column; }
      .trend-item { flex: initial; }
      .chart-container { height: 400px; }
    }
    
    /* Scrollbar polish */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

    /* Spacer to prevent content being hidden under fixed header */
    #headerSpacer { height: 0; width: 100%; display: block; }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Header -->
    <header>
      <div class="brand">
        <h1>YouTube 再生数ランキング & トレンド</h1>
        <div class="meta">
          <span id="lastUpdated">読み込み中...</span>
        </div>
      </div>
      <div class="controls">
        <input id="search" type="search" placeholder="キーワード検索...">
        <select id="scope">
          <option value="all">全範囲</option>
          <option value="banner">バナー別</option>
          <option value="unit">ユニット別</option>
        </select>
        <select id="groupFilter"><option value="all">グループ: 全て</option></select>
        <button id="clearGroups" class="btn-primary">クリア</button>
      </div>
    </header>

    <!-- Spacer inserted to keep original flow (header is fixed) -->
    <div id="headerSpacer" aria-hidden="true"></div>

    <div class="dashboard-grid">
      <!-- Trends Column -->
      <div class="card area-trend">
        <div class="card-header">トレンド</div>
        <div class="card-body">
          <div class="trend-list">
            <div class="trend-item" id="trendItemNew">
              <div class="label">新着動画</div>
              <div id="trendNew" class="val">—</div>
            </div>
            <div class="trend-item" id="trendItemWeek">
              <div class="label">急上昇 (7日間)</div>
              <div id="trendWeek" class="val">—</div>
            </div>
            <div class="trend-item" id="trendItemMonth">
              <div class="label">急上昇 (30日間)</div>
              <div id="trendMonth" class="val">—</div>
            </div>
            <div class="trend-item" id="trendItemTotal">
              <div class="label">累計トップ</div>
              <div id="trendTotal" class="val">—</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Chart Column -->
      <div class="card area-chart">
        <div class="card-header">
          <div style="display:flex;flex-direction:column;gap:4px;">
            <span id="selectedTitle" style="font-size:1.1rem;">動画を選択</span>
            <span id="selectedMeta" style="font-size:0.85rem; font-weight:400; color:var(--text-muted)">—</span>
          </div>
          <div id="selectedBadges" style="display:flex;gap:6px;"></div>
        </div>
        <div class="card-body">
          <div class="tabs">
            <button class="tab-mode active" data-period="all">全期間</button>
            <button class="tab-mode" data-period="30">30日</button>
            <button class="tab-mode" data-period="7">7日</button>
          </div>
          <div class="chart-container">
            <canvas id="trendChart"></canvas>
          </div>
          <div class="chart-metrics">
            <div class="metric-box">
              <div class="label">最新再生数</div>
              <div id="selectedViews" class="val">—</div>
            </div>
            <div class="metric-box">
              <div class="label">7日間増加</div>
              <div id="viewDelta7" class="val">—</div>
            </div>
            <div class="metric-box">
              <div class="label">30日間増加</div>
              <div id="viewDelta30" class="val">—</div>
            </div>
            <div class="metric-box">
              <div class="label">投稿日</div>
              <div id="publishDate" class="val">—</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Ranking Column -->
      <div class="card area-rank">
        <div class="card-header">
          <span>ランキング</span>
          <select id="sortMode" style="font-size:0.8rem; padding:4px; border-radius:6px; border:1px solid var(--border);">
            <option value="total">再生数順</option>
            <option value="published">新着順</option>
          </select>
        </div>
        <div class="card-body" style="padding:0;">
          <div id="rankList" class="rank-list" style="padding:12px;">
            <div style="text-align:center; padding:20px; color:var(--text-muted);">読み込み中...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
/* --- helper --- */

function fmt(n) {
  return n === null || n === undefined ? '—' : n.toLocaleString();
}

function escapeHtml(s) {
  return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function parseISOorDateString(s) {
  if (!s) return null;
  // accepts "YYYY-MM-DD" or full ISO
  if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return new Date(s + 'T00:00:00.000Z');
  return new Date(s);
}

/* --- Banner color mapping --- */
const BANNER_COLORS = {
  "一歌": "#33AAEE",
  "咲希": "#FFDD44",
  "穂波": "#EE6666",
  "志歩": "#BBDD22",
  "みのり": "#FFCCAA",
  "遥":   "#99CCFF",
  "愛莉": "#FFAACC",
  "雫":   "#99EEDD",
  "こはね": "#FF6699",
  "杏":   "#00BBDD",
  "彰人": "#FF7722",
  "冬弥": "#0077DD",
  "司":   "#FFBB00",
  "えむ": "#FF66BB",
  "寧々": "#33DD99",
  "類":   "#BB88EE",
  "奏":   "#BB6688",
  "まふゆ": "#8888CC",
  "絵名": "#CCAA88",
  "瑞希": "#DDAACC"
};

/* --- Unit fallback colors --- */
const UNIT_COLORS = {
  "レオニ": "#4455DD",
  "モモジャン": "#88DD44",
  "ビビバス": "#EE1166",
  "ワンダショ": "#FF9900",
  "ニーゴ": "#884499"
};

function hexToRgba(hex, alpha) {
  if (!hex) return "rgba(37,99,235," + alpha + ")";
  hex = hex.replace('#', '');
  if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
  const r = parseInt(hex.slice(0, 2), 16);
  const g = parseInt(hex.slice(2, 4), 16);
  const b = parseInt(hex.slice(4, 6), 16);
  return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
}

function mixWithWhite(hex) {
  if (!hex) hex = '#2563eb';
  hex = hex.replace('#', '');
  if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
  const r = parseInt(hex.slice(0, 2), 16);
  const g = parseInt(hex.slice(2, 4), 16);
  const b = parseInt(hex.slice(4, 6), 16);
  const mr = Math.round((r + 2 * 255) / 3);
  const mg = Math.round((g + 2 * 255) / 3);
  const mb = Math.round((b + 2 * 255) / 3);
  return '#' + [mr, mg, mb].map(n => n.toString(16).padStart(2, '0')).join('');
}

function mixWithWhiteRatio(hex, whiteParts) {
  if (!hex) hex = '#2563eb';
  if (!whiteParts || whiteParts < 0) whiteParts = 4;
  hex = hex.replace('#', '');
  if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
  const r = parseInt(hex.slice(0, 2), 16);
  const g = parseInt(hex.slice(2, 4), 16);
  const b = parseInt(hex.slice(4, 6), 16);
  const total = 1 + whiteParts;
  const mr = Math.round((r + whiteParts * 255) / total);
  const mg = Math.round((g + whiteParts * 255) / total);
  const mb = Math.round((b + whiteParts * 255) / total);
  return '#' + [mr, mg, mb].map(n => n.toString(16).padStart(2, '0')).join('');
}

/* --- Data structures (JS, no TS interfaces) --- */
/* History entry example: { datetime, date, views } */
/* VideoData example: { videoId, title, url, thumbnail, published, banner, unit, history: [...], views, latest, d7, d30 } */

/* --- Global State --- */
let DATA = [];
let DATA_UPDATED_AT = null;
let currentSelected = null;
let chart = null;

/* --- Elements --- */
const rankListEl = document.getElementById('rankList');
const sortModeEl = document.getElementById('sortMode');
const searchEl = document.getElementById('search');
const scopeEl = document.getElementById('scope');
const groupFilterEl = document.getElementById('groupFilter');
const clearBtn = document.getElementById('clearGroups');
const ctx = document.getElementById('trendChart').getContext('2d');

/* --- Group ordering --- */
const BANNER_ORDER = [
  "一歌", "咲希", "穂波", "志歩", "みのり", "遥", "愛莉", "雫", "こはね", "杏", "彰人", "冬弥", "司", "えむ", "寧々", "類", "奏", "まふゆ", "絵名", "瑞希"
];
const UNIT_ORDER = ["レオニ", "モモジャン", "ビビバス", "ワンダショ", "ニーゴ"];

function buildGroupOptions() {
  groupFilterEl.innerHTML = '<option value="all">グループ: 全て</option>';

  if (scopeEl.value === 'banner') {
    BANNER_ORDER.forEach(b => {
      groupFilterEl.insertAdjacentHTML('beforeend', `<option value="${escapeHtml(b)}">${escapeHtml(b)}</option>`);
    });
  } else if (scopeEl.value === 'unit') {
    UNIT_ORDER.forEach(u => {
      groupFilterEl.insertAdjacentHTML('beforeend', `<option value="${escapeHtml(u)}">${escapeHtml(u)}</option>`);
    });
  } else {
    groupFilterEl.insertAdjacentHTML('beforeend', '<option disabled>--- バナー ---</option>');
    BANNER_ORDER.forEach(b => groupFilterEl.insertAdjacentHTML('beforeend', `<option value="banner:${escapeHtml(b)}">${escapeHtml(b)}</option>`));
    groupFilterEl.insertAdjacentHTML('beforeend', '<option disabled>--- ユニット ---</option>');
    UNIT_ORDER.forEach(u => groupFilterEl.insertAdjacentHTML('beforeend', `<option value="unit:${escapeHtml(u)}">${escapeHtml(u)}</option>`));
  }
}

/* --- Prediction Utilities --- */

function preprocessHistory(history) {
  if (!Array.isArray(history)) return [];
  const pts = history.map(h => {
    const t = h.datetime ? new Date(h.datetime) : (h.date ? new Date(h.date + 'T00:00:00.000Z') : null);
    if (!t) return null;
    return { t: t, tsMin: t.getTime() / 60000, v: (h.views || 0) };
  }).filter((x) => !!x);
  
  pts.sort((a, b) => a.t.getTime() - b.t.getTime());
  
  const unique = [];
  for (const p of pts) {
    const last = unique[unique.length - 1];
    if (last && Math.abs(last.tsMin - p.tsMin) < 1e-6) {
      unique[unique.length - 1] = p;
    } else unique.push(p);
  }
  return unique;
}

function median(arr) {
  if (!arr || arr.length === 0) return 0;
  const s = arr.slice().sort((a, b) => a - b);
  const m = Math.floor(s.length / 2);
  if (s.length % 2 === 1) return s[m];
  return (s[m - 1] + s[m]) / 2;
}

function mad(arr) {
  if (!arr || arr.length === 0) return 0;
  const med = median(arr);
  const abs = arr.map(x => Math.abs(x - med));
  return median(abs);
}

function emaOfRates(rates, alpha) {
  if (!rates || rates.length === 0) return 0;
  let s = rates[0];
  for (let i = 1; i < rates.length; i++) {
    s = alpha * rates[i] + (1 - alpha) * s;
  }
  return s;
}

function computeAdvancedSlope(history) {
  const pts = preprocessHistory(history);
  const n = pts.length;
  if (n < 2) return { slope_reg: 0, slope_ema: 0, slope_final: 0, r2: 0, nPoints: n, medRate: 0 };

  const segRates = [];
  for (let i = 0; i < pts.length - 1; i++) {
    const dv = pts[i + 1].v - pts[i].v;
    const dt = pts[i + 1].tsMin - pts[i].tsMin;
    if (dt <= 0) continue;
    segRates.push(dv / dt);
  }
  if (segRates.length === 0) return { slope_reg: 0, slope_ema: 0, slope_final: 0, r2: 0, nPoints: n, medRate: 0 };

  const medRate = median(segRates);
  const madRate = mad(segRates) || 1e-6;

  const OUTLIER_K = 6;
  const goodIdx = [];
  for (let i = 0; i < pts.length; i++) {
    let ok = true;
    if (i < pts.length - 1) {
      const r = (pts[i + 1].v - pts[i].v) / Math.max(0.0001, (pts[i + 1].tsMin - pts[i].tsMin));
      if (Math.abs(r - medRate) > OUTLIER_K * madRate) ok = false;
    }
    if (i > 0) {
      const r2 = (pts[i].v - pts[i - 1].v) / Math.max(0.0001, (pts[i].tsMin - pts[i - 1].tsMin));
      if (Math.abs(r2 - medRate) > OUTLIER_K * madRate) ok = false;
    }
    if (ok) goodIdx.push(i);
  }
  
  const goodPts = goodIdx.map(i => pts[i]);
  if (goodPts.length < 2) goodPts.splice(0, goodPts.length, ...pts);

  const last = goodPts[goodPts.length - 1];
  const refTs = last.tsMin;
  const xs = goodPts.map(p => p.tsMin - refTs);
  const ys = goodPts.map(p => p.v);

  const HALF_LIFE_MIN = 180;
  const ln2 = Math.log(2);
  const ws = xs.map(x => Math.exp(-(Math.abs(x) / HALF_LIFE_MIN) * ln2));

  let S = 0, Sx = 0, Sy = 0, Sxx = 0, Sxy = 0;
  for (let i = 0; i < xs.length; i++) {
    const w = ws[i];
    const x = xs[i];
    const y = ys[i];
    S += w;
    Sx += w * x;
    Sy += w * y;
    Sxx += w * x * x;
    Sxy += w * x * y;
  }

  const denom = (S * Sxx - Sx * Sx);
  let slope_reg = 0;
  let intercept = 0;
  if (Math.abs(denom) > 1e-9) {
    slope_reg = (S * Sxy - Sx * Sy) / denom;
    intercept = (Sy - slope_reg * Sx) / S;
  } else {
    const totalDv = ys[ys.length - 1] - ys[0];
    const totalDt = (goodPts[goodPts.length - 1].tsMin - goodPts[0].tsMin) || 1;
    slope_reg = totalDv / totalDt;
    intercept = ys[ys.length - 1] - slope_reg * xs[xs.length - 1];
  }

  let SSres = 0;
  let SStot = 0;
  const yWeightedMean = Sy / S;
  for (let i = 0; i < xs.length; i++) {
    const w = ws[i];
    const x = xs[i];
    const y = ys[i];
    const yhat = intercept + slope_reg * x;
    SSres += w * Math.pow(y - yhat, 2);
    SStot += w * Math.pow(y - yWeightedMean, 2);
  }
  let r2 = 0;
  if (SStot > 1e-9) r2 = Math.max(0, 1 - (SSres / SStot));
  if (!isFinite(r2) || r2 < 0) r2 = 0;

  const instRates = [];
  for (let i = 0; i < pts.length - 1; i++) {
    const dv = pts[i + 1].v - pts[i].v;
    const dt = pts[i + 1].tsMin - pts[i].tsMin;
    if (dt <= 0) continue;
    instRates.push(dv / dt);
  }
  const alpha = 0.5;
  const slope_ema = emaOfRates(instRates, alpha);

  const nEff = Math.min(6, xs.length);
  let conf = r2 * (nEff / 6);
  if (conf < 0) conf = 0;
  if (conf > 1) conf = 1;

  let slope_final = conf * slope_reg + (1 - conf) * slope_ema;
  if (!isFinite(slope_final) || slope_final < 0) slope_final = Math.max(0, slope_ema, slope_reg, 0);
  
  const maxMultiplier = 10;
  const cap = Math.max(Math.abs(medRate) * maxMultiplier, 1);
  if (Math.abs(slope_final) > cap) slope_final = Math.sign(slope_final) * cap;

  return { slope_reg, slope_ema, slope_final, r2, nPoints: pts.length, medRate };
}

function predictValueAt(history, targetDate) {
  if (!history || history.length === 0) return 0;
  const last = history[history.length - 1];
  const lastTime = last.datetime ? new Date(last.datetime) : (last.date ? new Date(last.date + 'T00:00:00.000Z') : null);
  const lastViews = last.views || 0;
  if (!lastTime) return lastViews;
  const slopeInfo = computeAdvancedSlope(history);
  const slope = slopeInfo.slope_final || 0;
  const deltaMin = (targetDate.getTime() - lastTime.getTime()) / 60000;
  let pred = lastViews + slope * deltaMin;
  if (!isFinite(pred)) pred = lastViews;
  if (pred < 0) pred = 0;
  return Math.round(pred);
}

function earliestHistoryTime(history) {
  if (!history || history.length === 0) return null;
  const first = history[0];
  const t = first.datetime ? new Date(first.datetime) : (first.date ? new Date(first.date + 'T00:00:00.000Z') : null);
  return t;
}

function floorToHalfHour(date) {
  const d = new Date(date);
  d.setSeconds(0, 0);
  const m = d.getMinutes();
  if (m === 0 || m === 30) return d;
  if (m < 30) {
    d.setMinutes(0);
    return d;
  }
  d.setMinutes(30);
  return d;
}

function calcDeltaWithPrediction(history, days) {
  if (!history || history.length === 0) return 0;
  const now = new Date();
  const nowPred = predictValueAt(history, now);

  const target = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
  const targetTick = floorToHalfHour(target);
  const firstTime = earliestHistoryTime(history);
  let baseTick;
  if (!firstTime) {
    baseTick = targetTick;
  } else {
    const firstTick = floorToHalfHour(firstTime);
    if (targetTick.getTime() < firstTick.getTime()) baseTick = firstTick;
    else baseTick = targetTick;
  }
  const basePred = predictValueAt(history, baseTick);
  return Math.max(0, nowPred - basePred);
}

/* --- Logic --- */
let _lastTopPicks = { new: null, week: null, month: null, total: null };

async function loadData() {
  try {
    const res = await fetch('data/videos.json', { cache: "no-store" });
    if (!res.ok) throw new Error('data/videos.json が見つかりません: ' + res.status);
    const json = await res.json();
    DATA = json.videos || [];
    DATA_UPDATED_AT = json.updated_at || null;
    
    const lastEl = document.getElementById('lastUpdated');
    if (lastEl) {
      if (DATA_UPDATED_AT) {
        const d = new Date(DATA_UPDATED_AT);
        lastEl.innerText = '最終更新: ' + d.toLocaleString();
      } else {
        lastEl.innerText = '最終更新: —';
      }
    }

    buildGroupOptions();
    renderRankList();

    if (currentSelected && currentSelected.videoId) {
      const fresh = DATA.find(x => x.videoId === currentSelected.videoId);
      if (fresh) selectVideo(fresh);
      else selectDefault();
    } else {
      selectDefault();
    }

  } catch (err) {
    console.error(err);
    if (rankListEl) rankListEl.innerText = 'データ読み込みエラー: ' + err.message;
    const lastEl = document.getElementById('lastUpdated');
    if (lastEl) lastEl.innerText = '最終更新: エラー';
  }
}

function renderRankList() {
  const globalAnnotated = DATA.map(v => {
    const latestPred = predictValueAt(v.history || [], new Date());
    const d7 = calcDeltaWithPrediction(v.history || [], 7);
    const d30 = calcDeltaWithPrediction(v.history || [], 30);
    return Object.assign({}, v, { latest: latestPred, d7: d7, d30: d30 });
  });

  const topWeekGlobal = globalAnnotated.reduce((acc, cur) => cur.d7 > (acc.d7 || -Infinity) ? cur : acc, {});
  const topMonthGlobal = globalAnnotated.reduce((acc, cur) => cur.d30 > (acc.d30 || -Infinity) ? cur : acc, {});
  const topTotalGlobal = globalAnnotated.reduce((acc, cur) => cur.latest > (acc.latest || -Infinity) ? cur : acc, {});

  function getPublishDate(v) {
    if (!v) return null;
    if (v.published) {
      const d = parseISOorDateString(v.published);
      if (d && !isNaN(d.getTime())) return d;
    }
    const last = v.history && v.history.length ? v.history[v.history.length - 1] : null;
    if (last) {
      if (last.datetime) return new Date(last.datetime);
      if (last.date) return new Date(last.date + 'T00:00:00.000Z');
    }
    return null;
  }

  let topNewGlobal = null;
  for (const v of globalAnnotated) {
    const pd = getPublishDate(v);
    if (!pd) continue;
    if (!topNewGlobal) topNewGlobal = { video: v, date: pd };
    else {
      if (pd.getTime() > topNewGlobal.date.getTime()) {
        topNewGlobal = { video: v, date: pd };
      }
    }
  }

  _lastTopPicks.week = topWeekGlobal && topWeekGlobal.title ? topWeekGlobal : null;
  _lastTopPicks.month = topMonthGlobal && topMonthGlobal.title ? topMonthGlobal : null;
  _lastTopPicks.total = topTotalGlobal && topTotalGlobal.title ? topTotalGlobal : null;
  _lastTopPicks.new = topNewGlobal && topNewGlobal.video ? topNewGlobal.video : null;

  const trendWeekEl = document.getElementById('trendWeek');
  const trendMonthEl = document.getElementById('trendMonth');
  const trendTotalEl = document.getElementById('trendTotal');
  const trendNewEl = document.getElementById('trendNew');

  if (trendWeekEl) trendWeekEl.innerText = _lastTopPicks.week ? `${_lastTopPicks.week.title} — ${fmt(_lastTopPicks.week.d7)} 回` : '—';
  if (trendMonthEl) trendMonthEl.innerText = _lastTopPicks.month ? `${_lastTopPicks.month.title} — ${fmt(_lastTopPicks.month.d30)} 回` : '—';
  if (trendTotalEl) trendTotalEl.innerText = _lastTopPicks.total ? `${_lastTopPicks.total.title} — ${fmt(_lastTopPicks.total.latest)} 回` : '—';

  if (_lastTopPicks.new) {
    const d = getPublishDate(_lastTopPicks.new) || new Date();
    const yyyyMMdd = d.toISOString().slice(0, 10);
    if (trendNewEl) trendNewEl.innerText = `${_lastTopPicks.new.title} — ${yyyyMMdd}`;
  } else {
    if (trendNewEl) trendNewEl.innerText = '—';
  }

  function setupTrendItem(itemId, video) {
    const el = document.getElementById(itemId);
    if (!el) return;
    el.style.border = '';
    el.style.cursor = '';
    el.onclick = null;

    if (video) {
      const unitColor = UNIT_COLORS[video.unit] || null;
      if (unitColor) {
        el.style.border = `2px solid ${unitColor}`;
        el.style.background = mixWithWhiteRatio(unitColor, 4);
      } else {
        el.style.border = '1px solid var(--border)';
        el.style.background = '#f8fafc';
      }
      el.style.cursor = 'pointer';
      el.onclick = function (e) {
        e.stopPropagation();
        selectVideo(video);
      };
    } else {
      el.style.border = '1px solid var(--border)';
      el.style.cursor = 'default';
      el.style.background = '#f8fafc';
    }
  }

  setupTrendItem('trendItemWeek', _lastTopPicks.week);
  setupTrendItem('trendItemMonth', _lastTopPicks.month);
  setupTrendItem('trendItemTotal', _lastTopPicks.total);
  setupTrendItem('trendItemNew', _lastTopPicks.new);

  const mode = sortModeEl.value;
  const q = searchEl.value.trim().toLowerCase();
  let list = DATA.slice();

  const gv = groupFilterEl.value;
  if (gv && gv !== 'all') {
    if (gv.startsWith('banner:')) list = list.filter(v => v.banner === gv.slice(7));
    else if (gv.startsWith('unit:')) list = list.filter(v => v.unit === gv.slice(5));
    else {
      if (scopeEl.value === 'banner') list = list.filter(v => v.banner === gv);
      if (scopeEl.value === 'unit') list = list.filter(v => v.unit === gv);
    }
  }

  if (q) list = list.filter(v => {
    return (v.title || '').toLowerCase().includes(q) || (v.banner || '').toLowerCase().includes(q) || (v.unit || '').toLowerCase().includes(q);
  });

  const annotated = list.map(v => {
    const latestPred = predictValueAt(v.history || [], new Date());
    const d7 = calcDeltaWithPrediction(v.history || [], 7);
    const d30 = calcDeltaWithPrediction(v.history || [], 30);
    return Object.assign({}, v, { latest: latestPred, d7: d7, d30: d30 });
  });

  if (mode === 'total') {
    annotated.sort((a, b) => b.latest - a.latest);
  } else if (mode === 'published') {
    annotated.sort((a, b) => {
      const da = parseISOorDateString(a.published) || (a.history && a.history.length ? new Date(a.history[a.history.length - 1].datetime || a.history[a.history.length - 1].date + 'T00:00:00.000Z') : null);
      const db = parseISOorDateString(b.published) || (b.history && b.history.length ? new Date(b.history[b.history.length - 1].datetime || b.history[b.history.length - 1].date + 'T00:00:00.000Z') : null);
      const ta = da ? da.getTime() : 0;
      const tb = db ? db.getTime() : 0;
      return tb - ta;
    });
  }

  rankListEl.innerHTML = '';
  if (annotated.length === 0) {
    rankListEl.innerHTML = '<div style="padding:12px;color:var(--text-muted)">該当する動画がありません。</div>';
    return;
  }

  annotated.forEach((v, idx) => {
    const li = document.createElement('div');
    li.className = 'video-item';
    // Check if active
    if (currentSelected && currentSelected.videoId === v.videoId) {
      li.classList.add('active');
    }
    li.innerHTML = `
      <div class="rank-num">${idx + 1}</div>
      <img class="thumb" src="${escapeHtml(v.thumbnail)}" alt="thumb">
      <div class="meta">
        <div class="title">${escapeHtml(v.title)}</div>
        <div class="tags">
          <div class="badge banner-badge">${escapeHtml(v.banner)}</div>
          <div class="badge unit-badge">${escapeHtml(v.unit)}</div>
        </div>
        <div style="display:flex;justify-content:space-between;margin-top:4px;font-size:0.75rem;color:var(--text-muted)">
           <span>${fmt(v.latest)} 回</span>
           <span>▲${fmt(v.d7)} / 7d</span>
        </div>
      </div>
    `;
    
    const bannerBadge = li.querySelector('.banner-badge');
    if(bannerBadge){
      const bannerHex = (v.banner && BANNER_COLORS[v.banner]) ? BANNER_COLORS[v.banner] : '#e2e8f0';
      bannerBadge.style.backgroundColor = mixWithWhite(bannerHex);
      bannerBadge.style.color = '#1e293b';
      bannerBadge.classList.add('clickable');
      bannerBadge.addEventListener('click', function (e) {
        e.stopPropagation();
        scopeEl.value = 'all';
        buildGroupOptions();
        try { groupFilterEl.value = 'banner:' + v.banner; } catch (e) { }
        renderRankList();
        rankListEl.scrollTop = 0;
      });
    }
    
    const unitBadge = li.querySelector('.unit-badge');
    if(unitBadge){
      const unitHex = (v.unit && UNIT_COLORS[v.unit]) ? UNIT_COLORS[v.unit] : '#e2e8f0';
      unitBadge.style.backgroundColor = mixWithWhite(unitHex);
      unitBadge.style.color = '#1e293b';
      unitBadge.classList.add('clickable');
      unitBadge.addEventListener('click', function (e) {
        e.stopPropagation();
        scopeEl.value = 'all';
        buildGroupOptions();
        try { groupFilterEl.value = 'unit:' + v.unit; } catch (e) { }
        renderRankList();
        rankListEl.scrollTop = 0;
      });
    }

    li.addEventListener('click', () => selectVideo(v));
    rankListEl.appendChild(li);
  });
}

function selectVideo(v) {
  const vid = (typeof v === 'object' && v.videoId) ? v.videoId : (typeof v === 'string' ? v : null);
  let fresh;
  if (vid) fresh = DATA.find(x => x.videoId === vid);
  
  // Fallback if not found in DATA but passed as object
  if (!fresh && typeof v === 'object') fresh = v;

  currentSelected = fresh || null;
  if (!currentSelected) return;

  // Update styling in list
  const allItems = document.querySelectorAll('.video-item');
  allItems.forEach(el => el.classList.remove('active'));

  // Find and mark active item (best-effort)
  const items = Array.from(document.querySelectorAll('.video-item'));
  for (const it of items) {
    const titleEl = it.querySelector('.title');
    if (titleEl && titleEl.textContent === currentSelected.title) {
      it.classList.add('active');
      break;
    }
  }

  const titleEl = document.getElementById('selectedTitle');
  if (titleEl) titleEl.innerText = currentSelected.title || '（動画を選択してください）';
  const metaEl = document.getElementById('selectedMeta');
  if (metaEl) metaEl.innerHTML = `<a href="${currentSelected.url || '#'}" target="_blank" style="color:var(--primary);text-decoration:none;">YouTubeで見る &rarr;</a>`;

  const now = new Date();
  const predNow = predictValueAt(currentSelected.history || [], now);

  const selViewsEl = document.getElementById('selectedViews');
  if (selViewsEl) selViewsEl.innerText = fmt(predNow) + ' 回';
  const viewDelta7El = document.getElementById('viewDelta7');
  if (viewDelta7El) viewDelta7El.innerText = fmt(calcDeltaWithPrediction(currentSelected.history || [], 7)) + ' 回';
  const viewDelta30El = document.getElementById('viewDelta30');
  if (viewDelta30El) viewDelta30El.innerText = fmt(calcDeltaWithPrediction(currentSelected.history || [], 30)) + ' 回';
  const publishDateEl = document.getElementById('publishDate');
  if (publishDateEl) publishDateEl.innerText = currentSelected.published || '—';

  const badgesEl = document.getElementById('selectedBadges');
  if (badgesEl) {
    badgesEl.innerHTML = '';
    if(currentSelected.banner){
      const b = document.createElement('div');
      b.className = 'badge clickable';
      b.innerText = currentSelected.banner;
      const color = BANNER_COLORS[currentSelected.banner] || '#e2e8f0';
      b.style.background = mixWithWhite(color);
      b.style.color = '#1e293b';
      b.addEventListener('click', (e) => {
        e.stopPropagation();
        scopeEl.value = 'all';
        buildGroupOptions();
        try { groupFilterEl.value = 'banner:' + currentSelected.banner; } catch (e) { }
        renderRankList();
      });
      badgesEl.appendChild(b);
    }
    if(currentSelected.unit){
      const u = document.createElement('div');
      u.className = 'badge clickable';
      u.innerText = currentSelected.unit;
      const color = UNIT_COLORS[currentSelected.unit] || '#e2e8f0';
      u.style.background = mixWithWhite(color);
      u.style.color = '#1e293b';
      u.addEventListener('click', (e) => {
        e.stopPropagation();
        scopeEl.value = 'all';
        buildGroupOptions();
        try { groupFilterEl.value = 'unit:' + currentSelected.unit; } catch (e) { }
        renderRankList();
      });
      badgesEl.appendChild(u);
    }
  }

  drawChartForSelection(document.querySelector('.tab-mode.active') ? document.querySelector('.tab-mode.active').dataset.period : 'all');
}

function drawChartForSelection(period) {
  if (!currentSelected) return;
  const hist = currentSelected.history || [];
  
  if (hist.length === 0) {
    if (chart) { chart.destroy(); chart = null; }
    if(ctx) ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    return;
  }

  const now = new Date();
  let startTime;
  if (period === '7') {
    startTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  } else if (period === '30') {
    startTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
  } else {
    const firstRec = hist[0];
    const firstT = firstRec ? (firstRec.datetime ? new Date(firstRec.datetime) : (firstRec.date ? new Date(firstRec.date + 'T00:00:00.000Z') : null)) : null;
    if (firstT && !isNaN(firstT.getTime())) startTime = new Date(firstT);
    else startTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
  }

  if (startTime > now) startTime = new Date(now.getTime());
  let t0 = floorToHalfHour(startTime);
  if (t0 > now) t0 = floorToHalfHour(now);

  const ticks = [];
  const thirtyMin = 30 * 60 * 1000;
  for (let t = new Date(t0.getTime()); t.getTime() <= now.getTime(); t = new Date(t.getTime() + thirtyMin)) {
    ticks.push(new Date(t.getTime()));
    if (ticks.length > 2000) break;
  }
  if (ticks.length === 0 || Math.abs(ticks[ticks.length - 1].getTime() - now.getTime()) > 1000) {
    ticks.push(new Date(now.getTime()));
  }

  const labels = [];
  const data = [];
  const timesFull = [];

  for (const t of ticks) {
    const pred = predictValueAt(hist, t);
    labels.push(formatLabelForTick(t, period));
    data.push(pred);
    timesFull.push(t.toLocaleString());
  }

  const banner = currentSelected.banner;
  let colorHex = (banner && banner !== '-' && BANNER_COLORS[banner]) ? BANNER_COLORS[banner] : (UNIT_COLORS[currentSelected.unit] || '#3b82f6');
  const areaColor = hexToRgba(colorHex, 0.1);
  const lineColor = colorHex;

  if (chart) {
    chart.data.labels = labels;
    chart.data.datasets[0].data = data;
    chart.data.datasets[0].backgroundColor = areaColor;
    chart.data.datasets[0].borderColor = lineColor;
    chart.data.datasets[0].timesFull = timesFull;
    chart.update('none');
  } else {
    if(!ctx) return;
    chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          label: currentSelected.title,
          data: data,
          tension: 0.2,
          fill: true,
          backgroundColor: areaColor,
          borderColor: lineColor,
          pointRadius: 2,
          pointHoverRadius: 4,
          timesFull: timesFull
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'nearest', intersect: false },
        layout: { padding: { left: 0, right: 0, top: 10, bottom: 0 } },
        scales: {
          x: {
            display: true,
            grid: { display:false },
            ticks: { color: '#94a3b8', font: { size: 10 }, autoSkip: true, maxRotation: 0, minRotation: 0 },
          },
          y: {
            display: true,
            grid: { color: '#f1f5f9' },
            ticks: { color: '#94a3b8', font: { size: 10 }, callback: function(v){ return Intl.NumberFormat().format(v); } },
            beginAtZero: false
          }
        },
        plugins: {
          legend: { display: false },
          tooltip: {
            backgroundColor: 'rgba(255, 255, 255, 0.95)',
            titleColor: '#0f172a',
            bodyColor: '#0f172a',
            borderColor: '#e2e8f0',
            borderWidth: 1,
            padding: 10,
            callbacks: {
              title: function (items) {
                if (!items || !items.length) return '';
                const it = items[0];
                const ds = chart.data.datasets[it.datasetIndex];
                if (ds && Array.isArray(ds.timesFull) && ds.timesFull[it.dataIndex]) return ds.timesFull[it.dataIndex];
                return chart.data.labels[it.dataIndex] || '';
              },
              label: function (context) {
                return '推定 ' + Intl.NumberFormat().format(context.parsed.y) + ' 回';
              }
            }
          }
        }
      }
    });
  }

  const selViews = document.getElementById('selectedViews');
  if (selViews) selViews.innerText = Intl.NumberFormat().format(predictValueAt(hist, new Date())) + ' 回';
}

function formatLabelForTick(date, period) {
  const daysSpan = (function () {
    if (period === '7') return 7;
    if (period === '30') return 30;
    return 3; // all
  })();
  if (daysSpan > 1) {
    const m = String(date.getMonth() + 1);
    const d = String(date.getDate());
    return `${m}/${d}`;
  } else {
    const hh = String(date.getHours()).padStart(2, '0');
    const mm = String(date.getMinutes()).padStart(2, '0');
    return `${hh}:${mm}`;
  }
}

document.addEventListener('click', function (evt) {
  const chartAreaEl = document.querySelector('.card.area-chart');
  if (!chartAreaEl) return;
  if (!chartAreaEl.contains(evt.target)) {
    if (currentSelected) {
      const selViews = document.getElementById('selectedViews');
      if (selViews) selViews.innerText = Intl.NumberFormat().format(predictValueAt(currentSelected.history || [], new Date())) + ' 回';
    }
  }
});

/* --- Init --- */
if (clearBtn) clearBtn.addEventListener('click', function () {
  scopeEl.value = 'all';
  buildGroupOptions();
  try { groupFilterEl.value = 'all'; } catch (e) { }
  renderRankList();
});

sortModeEl.addEventListener('change', renderRankList);
searchEl.addEventListener('input', renderRankList);
scopeEl.addEventListener('change', function() { buildGroupOptions(); renderRankList(); });
groupFilterEl.addEventListener('change', renderRankList);

document.querySelectorAll('.tab-mode').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.tab-mode').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    drawChartForSelection(btn.dataset.period);
  });
});

function selectDefault() {
  if (DATA.length) {
    const sorted = DATA.slice().sort((a, b) => {
      const la = predictValueAt(a.history || [], new Date());
      const lb = predictValueAt(b.history || [], new Date());
      return lb - la;
    });
    selectVideo(sorted[0]);
  }
}

loadData();

const TWENTY_MIN = 20 * 60 * 1000;
setInterval(() => {
  loadData();
}, TWENTY_MIN);

/* --- New: keep header spacer height in sync with fixed header --- */
function adjustHeaderSpacer() {
  const header = document.querySelector('header');
  const spacer = document.getElementById('headerSpacer');
  if (!header || !spacer) return;
  // measure header height including margins
  const rect = header.getBoundingClientRect();
  // Add a small extra gap (10px) to match existing top offset
  spacer.style.height = Math.ceil(rect.height + 10) + 'px';
  // Also ensure header stays centered in very narrow viewports: adjust width to container if possible
  // (header CSS already sets width and max-width)
}
window.addEventListener('resize', adjustHeaderSpacer);
window.addEventListener('orientationchange', adjustHeaderSpacer);
document.addEventListener('DOMContentLoaded', adjustHeaderSpacer);
// In case DOM already parsed (script at end), run once
setTimeout(adjustHeaderSpacer, 50);

  </script>
</body>
</html>
