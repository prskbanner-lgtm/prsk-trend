<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>YouTube 再生数ランキング & トレンド ダッシュボード</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root{
      /* 白背景に合わせた配色 */
      --bg: #ffffff;
      --card: #ffffff;
      --muted: #596274;
      --text: #111827;
      --accent:#2563eb;
      --glass: rgba(15,23,42,0.03);
      --card-radius:12px;
      font-family: Inter, system-ui, "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo", sans-serif;
      color: var(--text);
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text);}
    .wrap{max-width:1200px;margin:28px auto;padding:20px;}
    /* Header stays mostly the same, but center the search visually */
    header{display:flex;gap:18px;align-items:center;justify-content:space-between;margin-bottom:18px;}
    header .title{font-size:20px;color:var(--text); font-weight:700;}
    .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .card{
      background:var(--card);
      border-radius:var(--card-radius);
      padding:14px;
      box-shadow: 0 6px 18px rgba(15,23,42,0.06);
      border: 1px solid rgba(15,23,42,0.04);
    }
    /* three-column layout (left: trend, center: main graph, right: ranking) */
    .grid{display:grid;grid-template-columns: 240px 1fr 240px;gap:16px;}
    select, button, input[type="search"]{
      background:#f7f9fb; border:1px solid rgba(15,23,42,0.06); color:var(--text); padding:8px 10px;border-radius:8px;
      font-size:13px;
    }
    select:focus, input[type="search"]:focus, button:focus{ outline: 2px solid rgba(37,99,235,0.12); outline-offset:2px; }
    button.primary{background:linear-gradient(90deg,#3b82f6,#60a5fa); color:#fff; font-weight:700; border:none; padding:9px 12px;}
    .rank-list{display:flex;flex-direction:column;gap:8px; max-height:520px; overflow:auto; padding-right:6px;}
    .video-item{display:flex;gap:10px;align-items:center;padding:8px;border-radius:10px;cursor:pointer;transition:background .12s, transform .06s}
    .video-item:hover{background:rgba(37,99,235,0.03); transform: translateY(-2px);}
    /* thumbnails smaller as requested */
    .thumb{width:64px;height:40px;border-radius:6px;background:#eee;flex:0 0 64px;object-fit:cover;border:1px solid rgba(15,23,42,0.04);}
    .meta{flex:1;min-width:0;}
    .meta .title{font-size:13px;color:var(--text);font-weight:600;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;}
    .meta .sub{font-size:12px;color:var(--muted);display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
    .badge{padding:4px 8px;border-radius:999px;font-size:12px;background:#f1f5f9;color:var(--muted);border:1px solid rgba(15,23,42,0.03)}
    .badge.clickable{cursor:pointer;}
    .rank-num{font-size:14px;color:var(--accent);width:28px;text-align:center;font-weight:700}
    .stats-row{display:flex;gap:8px;align-items:center; justify-content:flex-end;}
    .big-card{padding:16px;}
    .chart-area{height:320px;}
    .tabs{display:flex;gap:8px;margin-bottom:12px;}
    .tabs button{background:transparent;border:1px solid rgba(15,23,42,0.04);padding:8px 12px;border-radius:8px;color:var(--muted);cursor:pointer;}
    .tabs button.active{background:linear-gradient(90deg, rgba(37,99,235,0.08), rgba(37,99,235,0.04)); color:var(--text);border-color:transparent;}
    .top-metrics{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .metric{background:linear-gradient(180deg, rgba(15,23,42,0.02), rgba(15,23,42,0.01)); padding:8px;border-radius:10px; min-width:120px; border:1px solid rgba(15,23,42,0.04); flex:0 1 auto; display:flex;flex-direction:column;justify-content:center;}
    .metric .label{font-size:12px;color:var(--muted)}
    .metric .val{font-size:16px;color:var(--text);font-weight:700}
    .footer-note{font-size:12px;color:var(--muted);margin-top:8px}
    /* trend list */
    .trend-list{display:flex;flex-direction:column;gap:12px;}
    .trend-item{padding:12px;border-radius:10px;border:1px solid rgba(15,23,42,0.04);background:linear-gradient(180deg, rgba(15,23,42,0.01), rgba(15,23,42,0.00));}
    .trend-item .label{font-size:13px;color:var(--muted);margin-bottom:6px;}
    .trend-item .val{font-weight:700;color:var(--text);}
    /* responsive */
    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr; }
      .thumb{width:100px; height:56px; flex:0 0 100px;}
      .metric{min-width:100px; font-size:13px;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <div class="title">YouTube 再生数ランキング & トレンド</div>
        <div class="subtitle" style="font-size:13px;color:var(--muted)">
          <div id="lastUpdated" style="margin-top:6px;font-size:12px;color:var(--muted)">最終更新: 読み込み中...</div>
        </div>
      </div>
      <div class="controls">
        <input id="search" type="search" placeholder="タイトル / バナー / ユニット で検索">
        <select id="scope">
          <option value="all">全体</option>
          <option value="banner">バナー別</option>
          <option value="unit">ユニット別</option>
        </select>
        <select id="groupFilter"><option value="all">グループ: 全て</option></select>
        <button id="clearGroups" class="primary">グループ分けクリア</button>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT COLUMN: trend information -->
      <div>
        <div class="card">
          <strong style="color:var(--text)">トレンド情報</strong>
          <div style="margin-top:10px" class="trend-list">
            <div class="trend-item" id="trendItemNew">
              <div class="label">新着動画</div>
              <div id="trendNew" class="val">—</div>
            </div>
            <div class="trend-item" id="trendItemWeek">
              <div class="label">直近1週間で再生数伸びトップ</div>
              <div id="trendWeek" class="val">—</div>
            </div>
            <div class="trend-item" id="trendItemMonth">
              <div class="label">直近1ヶ月で再生数伸びトップ</div>
              <div id="trendMonth" class="val">—</div>
            </div>
            <div class="trend-item" id="trendItemTotal">
              <div class="label">累計再生数トップ</div>
              <div id="trendTotal" class="val">—</div>
            </div>
          </div>
        </div>

      </div>

      <!-- CENTER COLUMN: graph / details -->
      <div>
        <div class="card big-card">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div>
              <div id="selectedTitle" style="font-weight:700;font-size:16px;color:var(--text)">（動画を選択してください）</div>
              <div id="selectedMeta" style="font-size:13px;color:var(--muted);margin-top:6px">—</div>
            </div>
            <div class="stats-row">
              <!-- This area used to show 最新再生回数; changed to display unit & banner badges per request -->
              <div id="selectedBadges" style="display:flex;gap:6px;align-items:center;">
                <!-- badges will be injected here -->
              </div>
            </div>
          </div>

          <div style="margin-top:14px;" class="tabs">
            <button class="tab-mode active" data-period="all">全期間推移</button>
            <button class="tab-mode" data-period="30">直近30日</button>
            <button class="tab-mode" data-period="7">直近7日</button>
          </div>

          <div class="chart-area card" style="padding:12px;">
            <canvas id="trendChart" style="width:100%;height:320px"></canvas>
            <!-- bottom info removed as requested (do not display tapped date/value) -->
          </div>

          <!-- Four metrics placed inline (one line): 最新再生回数, 直近7日増分, 直近30日増分, 投稿日 -->
          <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:nowrap;align-items:center;">
            <div class="metric card" style="min-width:150px; padding:8px;">
              <div class="label">最新再生数</div>
              <div id="selectedViews" class="val">—</div>
            </div>
            <div class="metric card" style="min-width:150px; padding:8px;">
              <div class="label">直近7日増分</div>
              <div id="viewDelta7" class="val">—</div>
            </div>
            <div class="metric card" style="min-width:150px; padding:8px;">
              <div class="label">直近30日増分</div>
              <div id="viewDelta30" class="val">—</div>
            </div>
            <div class="metric card" style="min-width:150px; padding:8px;">
              <div class="label">投稿日</div>
              <div id="publishDate" class="val">—</div>
            </div>
          </div>
        </div>

      </div>

      <!-- RIGHT COLUMN: ranking -->
      <div>
        <div class="card">
          <div style="display:flex;align-items:center;justify-content:space-between;">
            <strong style="color:var(--text)">ランキング</strong>
            <div style="font-size:13px;color:var(--muted)">並び替え:
              <select id="sortMode">
                <option value="total">累計再生数（降順）</option>
                <option value="published">投稿日（新しい順）</option>
              </select>
            </div>
          </div>

          <div style="margin-top:12px;" class="rank-list card" id="rankList">
            読み込み中...
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* --- helper --- */
function fmt(n){ return n === null || n === undefined ? '—' : n.toLocaleString(); }
function safe(s){ return String(s||''); }
function parseISOorDateString(s){
  if(!s) return null;
  // accepts "YYYY-MM-DD" or full ISO
  if(/^\d{4}-\d{2}-\d{2}$/.test(s)) return new Date(s + 'T00:00:00.000Z');
  return new Date(s);
}

/* --- Banner color mapping (expanded 3-digit hex to full 6-digit) --- */
const BANNER_COLORS = {
  "一歌": "#33AAEE",
  "咲希": "#FFDD44",
  "穂波": "#EE6666",
  "志歩": "#BBDD22",
  "みのり": "#FFCCAA",
  "遥":   "#99CCFF",
  "愛莉": "#FFAACC",
  "雫":   "#99EEDD",
  "こはね": "#FF6699",
  "杏":   "#00BBDD",
  "彰人": "#FF7722",
  "冬弥": "#0077DD",
  "司":   "#FFBB00",
  "えむ": "#FF66BB",
  "寧々": "#33DD99",
  "類":   "#BB88EE",
  "奏":   "#BB6688",
  "まふゆ": "#8888CC",
  "絵名": "#CCAA88",
  "瑞希": "#DDAACC"
};

/* --- Unit fallback colors (expanded) --- */
const UNIT_COLORS = {
  "レオニ": "#4455DD",
  "モモジャン": "#88DD44",
  "ビビバス": "#EE1166",
  "ワンダショ": "#FF9900",
  "ニーゴ": "#884499"
};

/* convert hex color (#RRGGBB) to rgba string with alpha */
function hexToRgba(hex, alpha){
  if(!hex) return `rgba(37,99,235,${alpha})`;
  hex = hex.replace('#','');
  if(hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
  const r = parseInt(hex.slice(0,2),16);
  const g = parseInt(hex.slice(2,4),16);
  const b = parseInt(hex.slice(4,6),16);
  return `rgba(${r},${g},${b},${alpha})`;
}

/* mix provided hex color with white (#FFFFFF) in ratio 1:2 (1 color + 2 white) and return hex */
function mixWithWhite(hex){
  if(!hex) hex = '#2563eb';
  hex = hex.replace('#','');
  if(hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
  const r = parseInt(hex.slice(0,2),16);
  const g = parseInt(hex.slice(2,4),16);
  const b = parseInt(hex.slice(4,6),16);
  // mix: (color * 1 + white * 2) / 3 -> white components are 255
  const mr = Math.round((r + 2*255)/3);
  const mg = Math.round((g + 2*255)/3);
  const mb = Math.round((b + 2*255)/3);
  return '#' + [mr,mg,mb].map(n=> n.toString(16).padStart(2,'0')).join('');
}

/* --- load data/videos.json --- */
let DATA = [];
let DATA_UPDATED_AT = null;
async function loadData(){
  try{
    const res = await fetch('data/videos.json', {cache: "no-store"});
    if(!res.ok) throw new Error('data/videos.json が見つかりません: ' + res.status);
    const json = await res.json();
    DATA = json.videos || [];
    DATA_UPDATED_AT = json.updated_at || null;
    // show last updated in header
    const lastEl = document.getElementById('lastUpdated');
    if(DATA_UPDATED_AT){
      const d = new Date(DATA_UPDATED_AT);
      lastEl.innerText = '最終更新: ' + d.toLocaleString();
    } else {
      lastEl.innerText = '最終更新: —';
    }

    buildGroupOptions();
    renderRankList();
    selectDefault();
  }catch(err){
    console.error(err);
    document.getElementById('rankList').innerText = 'データ読み込みエラー: ' + err.message;
    const lastEl = document.getElementById('lastUpdated');
    lastEl.innerText = '最終更新: エラー';
  }
}

/* --- UI state and utilities --- */
const rankListEl = document.getElementById('rankList');
const sortModeEl = document.getElementById('sortMode');
const searchEl = document.getElementById('search');
const scopeEl = document.getElementById('scope');
const groupFilterEl = document.getElementById('groupFilter');
const clearBtn = document.getElementById('clearGroups');

/* --- Group ordering --- */
const BANNER_ORDER = [
  "一歌","咲希","穂波","志歩","みのり","遥","愛莉","雫","こはね","杏","彰人","冬弥","司","えむ","寧々","類","奏","まふゆ","絵名","瑞希"
];
const UNIT_ORDER = ["レオニ","モモジャン","ビビバス","ワンダショ","ニーゴ"];

function buildGroupOptions(){
  groupFilterEl.innerHTML = '<option value="all">グループ: 全て</option>';

  if(scopeEl.value === 'banner'){
    BANNER_ORDER.forEach(b => {
      groupFilterEl.insertAdjacentHTML('beforeend', `<option value="${escapeHtml(b)}">${escapeHtml(b)}</option>`);
    });
  } else if(scopeEl.value === 'unit'){
    UNIT_ORDER.forEach(u => {
      groupFilterEl.insertAdjacentHTML('beforeend', `<option value="${escapeHtml(u)}">${escapeHtml(u)}</option>`);
    });
  } else {
    groupFilterEl.insertAdjacentHTML('beforeend', '<option disabled>--- バナー ---</option>');
    BANNER_ORDER.forEach(b => groupFilterEl.insertAdjacentHTML('beforeend', `<option value="banner:${escapeHtml(b)}">${escapeHtml(b)}</option>`));
    groupFilterEl.insertAdjacentHTML('beforeend', '<option disabled>--- ユニット ---</option>');
    UNIT_ORDER.forEach(u => groupFilterEl.insertAdjacentHTML('beforeend', `<option value="unit:${escapeHtml(u)}">${escapeHtml(u)}</option>`));
  }
}

function escapeHtml(s){ return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

/* --- history utilities using datetime --- */
function lastHistoryEntry(history){
  if(!history || history.length===0) return null;
  return history[history.length-1];
}

function findClosestBefore(history, targetDate){
  if(!history || history.length===0) return null;
  let candidate = history[0];
  for(const rec of history){
    const t = rec.datetime ? new Date(rec.datetime) : (rec.date ? new Date(rec.date + 'T00:00:00.000Z') : null);
    if(!t) continue;
    if(t <= targetDate) candidate = rec;
    else break;
  }
  return candidate;
}

function calcDelta(history, days){
  if(!history || history.length===0) return 0;
  const lastRec = lastHistoryEntry(history);
  const lastDate = lastRec ? (lastRec.datetime ? new Date(lastRec.datetime) : (lastRec.date ? new Date(lastRec.date + 'T00:00:00.000Z') : null)) : null;
  if(!lastDate) return 0;
  const startDate = new Date(lastDate);
  startDate.setUTCDate(startDate.getUTCDate() - days);
  const startRec = findClosestBefore(history, startDate) || history[0];
  if(!startRec) return 0;
  const startViews = startRec.views || 0;
  const lastViews = lastRec.views || 0;
  return lastViews - startViews;
}

/* --- render ranking & trend picks --- */
let _lastTopPicks = { new:null, week:null, month:null, total:null };

function renderRankList(){
  const globalAnnotated = DATA.map(v=>{
    const latest = v.history && v.history.length ? (v.history[v.history.length-1].views || 0) : (v.views || 0);
    const d7 = calcDelta(v.history, 7);
    const d30 = calcDelta(v.history, 30);
    return {...v, latest, d7, d30};
  });

  const topWeekGlobal = globalAnnotated.reduce((acc,cur)=> cur.d7 > (acc.d7||-Infinity) ? cur : acc, {});
  const topMonthGlobal = globalAnnotated.reduce((acc,cur)=> cur.d30 > (acc.d30||-Infinity) ? cur : acc, {});
  const topTotalGlobal = globalAnnotated.reduce((acc,cur)=> cur.latest > (acc.latest||-Infinity) ? cur : acc, {});

  function getPublishDate(v){
    if(!v) return null;
    if(v.published){
      const d = parseISOorDateString(v.published);
      if(d && !isNaN(d)) return d;
    }
    const last = v.history && v.history.length ? v.history[v.history.length-1] : null;
    if(last){
      if(last.datetime) return new Date(last.datetime);
      if(last.date) return new Date(last.date + 'T00:00:00.000Z');
    }
    return null;
  }

  let topNewGlobal = null;
  for(const v of globalAnnotated){
    const pd = getPublishDate(v);
    if(!pd) continue;
    if(!topNewGlobal) topNewGlobal = { video: v, date: pd };
    else {
      if(pd.getTime() > topNewGlobal.date.getTime()){
        topNewGlobal = { video: v, date: pd };
      }
    }
  }

  _lastTopPicks.week = topWeekGlobal && topWeekGlobal.title ? topWeekGlobal : null;
  _lastTopPicks.month = topMonthGlobal && topMonthGlobal.title ? topMonthGlobal : null;
  _lastTopPicks.total = topTotalGlobal && topTotalGlobal.title ? topTotalGlobal : null;
  _lastTopPicks.new = topNewGlobal && topNewGlobal.video ? topNewGlobal.video : null;

  document.getElementById('trendWeek').innerText = _lastTopPicks.week ? `${_lastTopPicks.week.title} — ${fmt(_lastTopPicks.week.d7)} 回` : '—';
  document.getElementById('trendMonth').innerText = _lastTopPicks.month ? `${_lastTopPicks.month.title} — ${fmt(_lastTopPicks.month.d30)} 回` : '—';
  document.getElementById('trendTotal').innerText = _lastTopPicks.total ? `${_lastTopPicks.total.title} — ${fmt(_lastTopPicks.total.latest)} 回` : '—';

  if(_lastTopPicks.new){
    const d = getPublishDate(_lastTopPicks.new) || new Date();
    const yyyyMMdd = d.toISOString().slice(0,10);
    document.getElementById('trendNew').innerText = `${_lastTopPicks.new.title} — ${yyyyMMdd}`;
  } else {
    document.getElementById('trendNew').innerText = '—';
  }

  // attach click handlers and unit-color borders to trend items
  function setupTrendItem(itemId, video){
    const el = document.getElementById(itemId);
    if(!el) return;
    el.style.border = '';
    el.style.cursor = '';
    el.onclick = null;

    if(video){
      const unitColor = UNIT_COLORS[video.unit] || null;
      if(unitColor){
        el.style.border = `2px solid ${unitColor}`;
      } else {
        el.style.border = '1px solid rgba(15,23,42,0.04)';
      }
      el.style.cursor = 'pointer';
      el.onclick = function(e){
        e.stopPropagation();
        selectVideo(video);
      };
    } else {
      el.style.border = '1px solid rgba(15,23,42,0.04)';
      el.style.cursor = 'default';
    }
  }

  setupTrendItem('trendItemWeek', _lastTopPicks.week);
  setupTrendItem('trendItemMonth', _lastTopPicks.month);
  setupTrendItem('trendItemTotal', _lastTopPicks.total);
  setupTrendItem('trendItemNew', _lastTopPicks.new);

  // Now build the list that user sees (apply filters/search)
  const mode = sortModeEl.value;
  const q = searchEl.value.trim().toLowerCase();
  let list = DATA.slice();

  const gv = groupFilterEl.value;
  if(gv && gv !== 'all'){
    if(gv.startsWith('banner:')) list = list.filter(v=>v.banner === gv.slice(7));
    else if(gv.startsWith('unit:')) list = list.filter(v=>v.unit === gv.slice(5));
    else {
      if(scopeEl.value === 'banner') list = list.filter(v=>v.banner === gv);
      if(scopeEl.value === 'unit') list = list.filter(v=>v.unit === gv);
    }
  }

  if(q) list = list.filter(v=>{
    return (v.title||'').toLowerCase().includes(q) || (v.banner||'').toLowerCase().includes(q) || (v.unit||'').toLowerCase().includes(q);
  });

  const annotated = list.map(v=>{
    const latest = v.history && v.history.length ? (v.history[v.history.length-1].views || 0) : (v.views || 0);
    const d7 = calcDelta(v.history, 7);
    const d30 = calcDelta(v.history, 30);
    return {...v, latest, d7, d30};
  });

  if(mode === 'total') {
    annotated.sort((a,b)=>b.latest - a.latest);
  } else if(mode === 'published') {
    annotated.sort((a,b)=>{
      const da = parseISOorDateString(a.published) || (a.history && a.history.length ? new Date(a.history[a.history.length-1].datetime || a.history[a.history.length-1].date + 'T00:00:00.000Z') : null);
      const db = parseISOorDateString(b.published) || (b.history && b.history.length ? new Date(b.history[b.history.length-1].datetime || b.history[b.history.length-1].date + 'T00:00:00.000Z') : null);
      const ta = da ? da.getTime() : 0;
      const tb = db ? db.getTime() : 0;
      return tb - ta; // newest first
    });
  }

  rankListEl.innerHTML = '';
  if(annotated.length === 0){
    rankListEl.innerText = '該当する動画がありません。';
    return;
  }

  annotated.forEach((v, idx)=>{
    const li = document.createElement('div');
    li.className = 'video-item';
    li.innerHTML = `
      <div class="rank-num">${idx+1}</div>
      <img class="thumb" src="${escapeHtml(v.thumbnail)}" alt="thumb">
      <div class="meta">
        <div class="title">${escapeHtml(v.title)}</div>
        <div class="sub">
          <div class="badge">${escapeHtml(v.banner)}</div>
          <div class="badge">${escapeHtml(v.unit)}</div>
          <div style="margin-left:auto;color:var(--muted)">${fmt(v.latest)} 回</div>
          <div style="color:var(--muted);font-size:12px">▲${fmt(v.d7)} / 7d</div>
        </div>
      </div>
    `;
    // after element created, color the badges by mixing with white 1:2 and attach click handlers
    const badgeEls = li.querySelectorAll('.badge');
    if(badgeEls && badgeEls.length >= 1){
      const bannerHex = (v.banner && BANNER_COLORS[v.banner]) ? BANNER_COLORS[v.banner] : '#2563eb';
      const blended = mixWithWhite(bannerHex);
      badgeEls[0].style.backgroundColor = blended;
      badgeEls[0].style.color = '#111827';
      badgeEls[0].style.border = '1px solid rgba(15,23,42,0.04)';
      badgeEls[0].classList.add('clickable');
      // click -> jump to banner filter
      badgeEls[0].addEventListener('click', function(e){
        e.stopPropagation();
        scopeEl.value = 'all';
        buildGroupOptions();
        try { groupFilterEl.value = `banner:${v.banner}`; } catch(e){}
        renderRankList();
        rankListEl.scrollTop = 0;
      });
    }
    if(badgeEls && badgeEls.length >= 2){
      const unitHex = (v.unit && UNIT_COLORS[v.unit]) ? UNIT_COLORS[v.unit] : '#2563eb';
      const blendedU = mixWithWhite(unitHex);
      badgeEls[1].style.backgroundColor = blendedU;
      badgeEls[1].style.color = '#111827';
      badgeEls[1].style.border = '1px solid rgba(15,23,42,0.04)';
      badgeEls[1].classList.add('clickable');
      // click -> jump to unit filter
      badgeEls[1].addEventListener('click', function(e){
        e.stopPropagation();
        scopeEl.value = 'all';
        buildGroupOptions();
        try { groupFilterEl.value = `unit:${v.unit}`; } catch(e){}
        renderRankList();
        rankListEl.scrollTop = 0;
      });
    }

    li.addEventListener('click', ()=> selectVideo(v));
    rankListEl.appendChild(li);
  });
}

/* --- chart & selection --- */
let currentSelected = null;
const ctx = document.getElementById('trendChart').getContext('2d');
let chart = null;

function selectVideo(v){
  currentSelected = v;
  document.getElementById('selectedTitle').innerText = v.title;
  // keep link only in selectedMeta to avoid duplicate banner/unit display
  document.getElementById('selectedMeta').innerHTML = `<a href="${v.url}" target="_blank" style="color:var(--accent)">${v.url ? 'YouTubeへ' : ''}</a>`;
  // show the latest API-fetched value (should be the last history entry's views)
  const lastRec = v.history && v.history.length ? v.history[v.history.length-1] : null;
  const lastViews = lastRec ? lastRec.views : (v.views || 0);
  document.getElementById('selectedViews').innerText = fmt(lastViews) + ' 回';
  document.getElementById('viewDelta7').innerText = fmt(calcDelta(v.history,7)) + ' 回';
  document.getElementById('viewDelta30').innerText = fmt(calcDelta(v.history,30)) + ' 回';
  document.getElementById('publishDate').innerText = v.published || '—';

  // Show badges (unit and banner) in the right-top stats area (replaces the old 最新再生数)
  const badgesEl = document.getElementById('selectedBadges');
  if(badgesEl){
    badgesEl.innerHTML = '';

    const bannerBadge = document.createElement('div');
    bannerBadge.className = 'badge clickable';
    bannerBadge.innerText = v.banner || '—';
    const bannerHex = (v.banner && BANNER_COLORS[v.banner]) ? BANNER_COLORS[v.banner] : '#2563eb';
    bannerBadge.style.backgroundColor = mixWithWhite(bannerHex);
    bannerBadge.style.color = '#111827';
    bannerBadge.style.border = '1px solid rgba(15,23,42,0.04)';
    // badge click -> jump to banner classification
    bannerBadge.addEventListener('click', function(e){
      e.stopPropagation();
      scopeEl.value = 'all';
      buildGroupOptions();
      try { groupFilterEl.value = `banner:${v.banner}`; } catch(e){}
      renderRankList();
      rankListEl.scrollTop = 0;
    });
    badgesEl.appendChild(bannerBadge);

    const unitBadge = document.createElement('div');
    unitBadge.className = 'badge clickable';
    unitBadge.innerText = v.unit || '—';
    const unitHex = (v.unit && UNIT_COLORS[v.unit]) ? UNIT_COLORS[v.unit] : '#2563eb';
    unitBadge.style.backgroundColor = mixWithWhite(unitHex);
    unitBadge.style.color = '#111827';
    unitBadge.style.border = '1px solid rgba(15,23,42,0.04)';
    // badge click -> jump to unit classification
    unitBadge.addEventListener('click', function(e){
      e.stopPropagation();
      scopeEl.value = 'all';
      buildGroupOptions();
      try { groupFilterEl.value = `unit:${v.unit}`; } catch(e){}
      renderRankList();
      rankListEl.scrollTop = 0;
    });
    badgesEl.appendChild(unitBadge);
  }

  drawChartForSelection('all');
}

function drawChartForSelection(period){
  if(!currentSelected) return;
  const hist = currentSelected.history || [];
  if(hist.length === 0) {
    if(chart){ chart.destroy(); chart = null; }
    ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    return;
  }
  // convert to entries with timestamp and views
  const pts = hist.map(h => {
    const ts = h.datetime ? new Date(h.datetime) : (h.date ? new Date(h.date + 'T00:00:00.000Z') : null);
    return ts ? { t: ts, v: (h.views || 0) } : null;
  }).filter(Boolean);

  let points = pts.slice();
  if(period === '7') {
    const cutoff = new Date(points[points.length-1].t);
    cutoff.setUTCDate(cutoff.getUTCDate() - 7);
    points = points.filter(p => p.t >= cutoff);
  } else if(period === '30') {
    const cutoff = new Date(points[points.length-1].t);
    cutoff.setUTCDate(cutoff.getUTCDate() - 30);
    points = points.filter(p => p.t >= cutoff);
  }

  // labels: date only (YYYY-MM-DD) for axis ticks
  const labels = points.map(p => p.t.toISOString().slice(0,10));
  // data values
  const data = points.map(p => p.v);
  // full timestamp strings for tooltip (localized including time)
  const timesFull = points.map(p => {
    try { return p.t.toLocaleString(); } catch(e) { return p.t.toISOString(); }
  });

  // choose color: if banner is '-' or missing use unit color; otherwise banner color
  const banner = currentSelected.banner;
  let colorHex = (banner && banner !== '-' && BANNER_COLORS[banner]) ? BANNER_COLORS[banner] : (UNIT_COLORS[currentSelected.unit] || '#2563eb');
  const areaColor = hexToRgba(colorHex, 0.06);
  const lineColor = colorHex;

  if(chart) chart.destroy();
  chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label: currentSelected.title,
        data,
        tension:0.2,
        fill:true,
        backgroundColor: areaColor,
        borderColor: lineColor,
        pointRadius:3,
        // attach times array so tooltip callback can access time including clock
        timesFull: timesFull
      }]
    },
    options: {
      responsive:true, maintainAspectRatio:false,
      interaction: { mode: 'nearest', intersect: false },
      layout: { padding: { left: 0, right: 0, top: 0, bottom: 0 } },
      scales: {
        x: {
          display:true,
          grid:{color:'rgba(15,23,42,0.03)'},
          ticks:{ color:'#6b7c93', font: { size:10 }, autoSkip: true, maxRotation:0, minRotation:0 },
          type: 'category'
        },
        y: {
          display:true,
          grid:{color:'rgba(15,23,42,0.03)'},
          ticks:{ color:'#6b7c93', font: { size:10 }, padding: 2, callback: v => Intl.NumberFormat().format(v) },
          beginAtZero: false,
          offset: false
        }
      },
      plugins: {
        legend:{display:false},
        tooltip:{
          callbacks:{
            // show localized full datetime (including time) as tooltip title
            title: function(items){
              if(!items || !items.length) return '';
              const it = items[0];
              const ds = chart.data.datasets[it.datasetIndex];
              if(ds && Array.isArray(ds.timesFull) && ds.timesFull[it.dataIndex]) return ds.timesFull[it.dataIndex];
              // fallback to label (date)
              return chart.data.labels[it.dataIndex] || '';
            },
            // show views as label
            label: function(context){
              return `${Intl.NumberFormat().format(context.parsed.y)} 回`;
            }
          }
        }
      }
    }
  });

  // Note: we intentionally do not add an external click-to-show-text handler (per previous request).
}

/* --- clicking outside the chart restores latest API value into the metric --- */
document.addEventListener('click', function(evt){
  const chartAreaEl = document.querySelector('.chart-area');
  if(!chartAreaEl) return;
  if(!chartAreaEl.contains(evt.target)){
    // restore latest value to the true latest record when clicking outside chart area
    if(currentSelected){
      const lastRec = currentSelected.history && currentSelected.history.length ? currentSelected.history[currentSelected.history.length-1] : null;
      const lastViews = lastRec ? lastRec.views : (currentSelected.views || 0);
      const selViews = document.getElementById('selectedViews');
      if(selViews) selViews.innerText = `${Intl.NumberFormat().format(lastViews)} 回`;
    }
  }
});

/* --- event binding --- */
// replaced reload button by clearGroups button (clears group filters)
if(clearBtn) clearBtn.addEventListener('click', function(){
  scopeEl.value = 'all';
  buildGroupOptions();
  try { groupFilterEl.value = 'all'; } catch(e){}
  renderRankList();
  rankListEl.scrollTop = 0;
});

sortModeEl.addEventListener('change', renderRankList);
searchEl.addEventListener('input', renderRankList);
scopeEl.addEventListener('change', ()=>{ buildGroupOptions(); renderRankList(); });
groupFilterEl.addEventListener('change', renderRankList);

// safe binding for optional buttons
const btnAll = document.getElementById('btnAll');
if(btnAll) btnAll.addEventListener('click', ()=> { scopeEl.value='all'; buildGroupOptions(); renderRankList(); });
const btnBanner = document.getElementById('btnBanner');
if(btnBanner) btnBanner.addEventListener('click', ()=> { scopeEl.value='banner'; buildGroupOptions(); renderRankList(); });
const btnUnit = document.getElementById('btnUnit');
if(btnUnit) btnUnit.addEventListener('click', ()=> { scopeEl.value='unit'; buildGroupOptions(); renderRankList(); });

document.querySelectorAll('.tab-mode').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.tab-mode').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    drawChartForSelection(btn.dataset.period);
  });
});

/* --- default select --- */
function selectDefault(){
  if(DATA.length) {
    const sorted = DATA.slice().sort((a,b)=> {
      const la = a.history && a.history.length ? a.history[a.history.length-1].views : (a.views||0);
      const lb = b.history && b.history.length ? b.history[b.history.length-1].views : (b.views||0);
      return lb - la;
    });
    selectVideo(sorted[0]);
  }
}

/* --- initial load --- */
loadData();
</script>
</body>
</html>
