<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>YouTube 再生数ランキング & トレンド（モダン）</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root{
      --bg-body:#0f172a10; /* subtle */
      --bg-card:#ffffff;
      --text-main:#0f172a;
      --text-muted:#64748b;
      --primary:#2563eb;
      --accent:#7c3aed;
      --glass: rgba(255,255,255,0.75);
      --border:#e6eef8;
      --radius-lg:14px;
      --radius-md:10px;
      --shadow-sm: 0 6px 18px rgba(16,24,40,0.06);
      --shadow-md: 0 10px 30px rgba(16,24,40,0.08);
    }

    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#f8fafc 0%, #f1f5f9 100%);font-family:'Inter','Noto Sans JP',sans-serif;color:var(--text-main);-webkit-font-smoothing:antialiased}

    .app-container{max-width:1400px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:18px}

    /* Header */
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:14px 18px;border-radius:14px;background:var(--glass);backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,0.6);box-shadow:var(--shadow-sm);position:fixed;top:14px;left:50%;transform:translateX(-50%);width:calc(100% - 28px);max-width:1400px;z-index:1000}
    .brand h1{margin:0;font-size:1.05rem;font-weight:700}
    .brand .meta{font-size:0.8rem;color:var(--text-muted);margin-top:4px}
    .controls{display:flex;gap:8px;align-items:center}
    .controls input,.controls select,.controls button{padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:#fff;font-size:0.9rem}
    .btn-primary{background:var(--primary);color:#fff;border:none;font-weight:700;cursor:pointer}

    #headerSpacer{height:0;width:100%}

    /* Main grid: trend (full width on top) + below: chart (left) + rank (right) */
    .dashboard-grid{display:grid;grid-template-columns:1fr;grid-template-areas:"trend" "main";gap:18px}

    .area-trend{grid-area:trend}
    .area-main{grid-area:main;display:grid;grid-template-columns:1fr;gap:18px}

    /* larger screens: trend top full width, main becomes two columns */
    @media(min-width:900px){
      .dashboard-grid{grid-template-columns:1fr;grid-template-areas:"trend" "main"}
      .area-main{grid-template-columns:1fr 380px}
    }

    /* Cards */
    .card{background:var(--bg-card);border-radius:var(--radius-lg);box-shadow:var(--shadow-md);border:1px solid var(--border);overflow:hidden;display:flex;flex-direction:column}
    .card-header{padding:14px;border-bottom:1px solid var(--border);font-weight:700;background:linear-gradient(180deg,#ffffff,#fbfdff);display:flex;justify-content:space-between;align-items:center}
    .card-body{padding:14px}

    /* Trend top: horizontal thumbnails */
    .trend-top{display:grid;grid-auto-flow:column;gap:12px;overflow-x:auto;padding-bottom:8px}
    .trend-card{min-width:220px;max-width:320px;display:flex;gap:12px;align-items:center;padding:10px;border-radius:12px;background:linear-gradient(180deg,#ffffff,#fbfcff);border:1px solid var(--border);box-shadow:0 6px 14px rgba(2,6,23,0.04);cursor:pointer;transition:transform .16s,box-shadow .16s}
    .trend-card:hover{transform:translateY(-6px);box-shadow:0 18px 40px rgba(2,6,23,0.08)}
    .trend-thumb{width:84px;height:56px;object-fit:cover;border-radius:8px;background:#e6eef8;flex-shrink:0}
    .trend-body{display:flex;flex-direction:column;min-width:0}
    .trend-title{font-size:0.95rem;font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .trend-meta{font-size:0.78rem;color:var(--text-muted);margin-top:6px}

    /* Chart area */
    .area-chart .card-body{display:flex;flex-direction:column;gap:12px}
    .tabs{display:flex;gap:8px;background:#f1f5f9;padding:6px;border-radius:12px;width:fit-content}
    .tabs button{border:none;background:transparent;padding:8px 12px;border-radius:8px;font-weight:600;color:var(--text-muted);cursor:pointer}
    .tabs button.active{background:white;color:var(--primary);box-shadow:0 4px 12px rgba(37,99,235,0.08)}

    .chart-container{position:relative;height:320px;width:100%;border-radius:10px;overflow:hidden}
    @media(min-width:1200px){.chart-container{height:420px}}

    .chart-metrics{display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:12px}
    .metric-box{background:#f8fafc;padding:10px;border-radius:10px;border:1px solid var(--border);text-align:center}
    .metric-box .label{font-size:0.78rem;color:var(--text-muted)}
    .metric-box .val{font-weight:800;margin-top:6px}

    /* Rank list */
    .rank-list{display:flex;flex-direction:column;gap:10px;max-height:640px;overflow:auto;padding-right:6px}
    .video-item{display:flex;gap:12px;align-items:center;padding:10px;border-radius:10px;transition:background .12s;border:1px solid transparent}
    .video-item:hover{background:#fbfdff}
    .video-item.active{background:linear-gradient(90deg,#eff6ff,#f8fbff);border-color:#dbeafe}
    .rank-num{font-weight:900;color:var(--primary);width:36px;text-align:center}
    .thumb{width:96px;height:56px;object-fit:cover;border-radius:8px;background:#e6eef8}
    .meta{min-width:0}
    .meta .title{font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .meta .tags{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
    .badge{font-size:0.75rem;padding:4px 8px;border-radius:999px;background:#eef2ff;color:var(--text-muted)}

    /* small screens tweaks */
    @media(max-width:599px){
      header{padding:12px 14px}
      .trend-card{min-width:200px}
      .thumb{width:86px;height:48px}
    }

    /* polished scrollbar */
    ::-webkit-scrollbar{height:8px;width:8px}
    ::-webkit-scrollbar-thumb{background:#cbd5e1;border-radius:8px}

  </style>
</head>
<body>
  <div class="app-container">
    <header>
      <div class="brand">
        <h1>YouTube 再生数ランキング & トレンド</h1>
        <div class="meta"><span id="lastUpdated">読み込み中...</span></div>
      </div>
      <div class="controls">
        <input id="search" type="search" placeholder="キーワード検索...">
        <select id="scope"><option value="all">全範囲</option><option value="banner">バナー別</option><option value="unit">ユニット別</option></select>
        <select id="groupFilter"><option value="all">グループ: 全て</option></select>
        <button id="clearGroups" class="btn-primary">クリア</button>
      </div>
    </header>

    <div id="headerSpacer" aria-hidden="true"></div>

    <div class="dashboard-grid">
      <!-- Trend Top -->
      <div class="card area-trend">
        <div class="card-header">トレンド</div>
        <div class="card-body">
          <div id="trendTop" class="trend-top" aria-live="polite">
            <!-- JS will populate trend cards here using ids: trendItemNew, trendItemWeek, trendItemMonth, trendItemTotal -->
            <div id="trendItemNew" class="trend-card" role="button" tabindex="0">
              <img class="trend-thumb" src="" alt="thumb">
              <div class="trend-body"><div class="trend-title">読み込み中...</div><div class="trend-meta">—</div></div>
            </div>
            <div id="trendItemWeek" class="trend-card" role="button" tabindex="0">
              <img class="trend-thumb" src="" alt="thumb">
              <div class="trend-body"><div class="trend-title">読み込み中...</div><div class="trend-meta">—</div></div>
            </div>
            <div id="trendItemMonth" class="trend-card" role="button" tabindex="0">
              <img class="trend-thumb" src="" alt="thumb">
              <div class="trend-body"><div class="trend-title">読み込み中...</div><div class="trend-meta">—</div></div>
            </div>
            <div id="trendItemTotal" class="trend-card" role="button" tabindex="0">
              <img class="trend-thumb" src="" alt="thumb">
              <div class="trend-body"><div class="trend-title">読み込み中...</div><div class="trend-meta">—</div></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Main: Chart (left) + Ranking (right) -->
      <div class="area-main">
        <div class="card area-chart">
          <div class="card-header">
            <div style="display:flex;flex-direction:column;gap:4px;min-width:0;">
              <span id="selectedTitle" style="font-size:1.05rem;">動画を選択</span>
              <span id="selectedMeta" style="font-size:0.85rem;color:var(--text-muted)">—</span>
            </div>
            <div id="selectedBadges" style="display:flex;gap:8px"></div>
          </div>
          <div class="card-body">
            <div class="tabs" role="tablist">
              <button class="tab-mode active" data-period="all">全期間</button>
              <button class="tab-mode" data-period="30">30日</button>
              <button class="tab-mode" data-period="7">7日</button>
            </div>
            <div class="chart-container"><canvas id="trendChart"></canvas></div>
            <div class="chart-metrics">
              <div class="metric-box"><div class="label">最新再生数</div><div id="selectedViews" class="val">—</div></div>
              <div class="metric-box"><div class="label">7日間増加</div><div id="viewDelta7" class="val">—</div></div>
              <div class="metric-box"><div class="label">30日間増加</div><div id="viewDelta30" class="val">—</div></div>
              <div class="metric-box"><div class="label">投稿日</div><div id="publishDate" class="val">—</div></div>
            </div>
          </div>
        </div>

        <div class="card area-rank">
          <div class="card-header"><span>ランキング</span>
            <select id="sortMode" style="font-size:0.85rem;padding:6px;border-radius:8px;border:1px solid var(--border)">
              <option value="total">再生数順</option>
              <option value="published">新着順</option>
            </select>
          </div>
          <div class="card-body" style="padding:12px">
            <div id="rankList" class="rank-list"><div style="text-align:center;padding:20px;color:var(--text-muted)">読み込み中...</div></div>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
/*
  変更点:
  - 表示デザインをモダンに変更
  - トレンドアイテムをサムネイル付きのカード（上部横スクロール）に変更
  - 既存のIDや関数（renderRankList, selectVideo, predictValueAt 等）はそのまま残し
    見た目の変更を最小限のJS修正で実装しています。
*/

// 既存のユーティリティ関数群は元ファイルと同一の実装を流用しています。
// （ここではコード量を縮めるため、元ファイルの関数をそのままコピーしてあります。）

/* --- helper --- */

function fmt(n){return n===null||n===undefined?'—':n.toLocaleString();}
function escapeHtml(s){return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');}
function parseISOorDateString(s){if(!s)return null; if(/^\d{4}-\d{2}-\d{2}$/.test(s)) return new Date(s+'T00:00:00.000Z'); return new Date(s);} 

/* --- color helpers (コピー) --- */
const BANNER_COLORS = {"一歌":"#33AAEE","咲希":"#FFDD44","穂波":"#EE6666","志歩":"#BBDD22","みのり":"#FFCCAA","遥":"#99CCFF","愛莉":"#FFAACC","雫":"#99EEDD","こはね":"#FF6699","杏":"#00BBDD","彰人":"#FF7722","冬弥":"#0077DD","司":"#FFBB00","えむ":"#FF66BB","寧々":"#33DD99","類":"#BB88EE","奏":"#BB6688","まふゆ":"#8888CC","絵名":"#CCAA88","瑞希":"#DDAACC"};
const UNIT_COLORS = {"レオニ":"#4455DD","モモジャン":"#88DD44","ビビバス":"#EE1166","ワンダショ":"#FF9900","ニーゴ":"#884499"};
function hexToRgba(hex, alpha){if(!hex) return "rgba(37,99,235,"+alpha+")"; hex=hex.replace('#',''); if(hex.length===3) hex=hex.split('').map(c=>c+c).join(''); const r=parseInt(hex.slice(0,2),16); const g=parseInt(hex.slice(2,4),16); const b=parseInt(hex.slice(4,6),16); return "rgba("+r+","+g+","+b+","+alpha+")";}
function mixWithWhite(hex){if(!hex) hex='#2563eb'; hex=hex.replace('#',''); if(hex.length===3) hex=hex.split('').map(c=>c+c).join(''); const r=parseInt(hex.slice(0,2),16); const g=parseInt(hex.slice(2,4),16); const b=parseInt(hex.slice(4,6),16); const mr=Math.round((r+2*255)/3); const mg=Math.round((g+2*255)/3); const mb=Math.round((b+2*255)/3); return '#'+[mr,mg,mb].map(n=>n.toString(16).padStart(2,'0')).join('');}
function mixWithWhiteRatio(hex, whiteParts){ if(!hex) hex='#2563eb'; if(!whiteParts||whiteParts<0) whiteParts=4; hex=hex.replace('#',''); if(hex.length===3) hex=hex.split('').map(c=>c+c).join(''); const r=parseInt(hex.slice(0,2),16); const g=parseInt(hex.slice(2,4),16); const b=parseInt(hex.slice(4,6),16); const total=1+whiteParts; const mr=Math.round((r+whiteParts*255)/total); const mg=Math.round((g+whiteParts*255)/total); const mb=Math.round((b+whiteParts*255)/total); return '#'+[mr,mg,mb].map(n=>n.toString(16).padStart(2,'0')).join(''); }

/* --- 省略せず元ロジックをほぼそのまま採用 (主要な関数は元ファイルと同じ) --- */

// ここから下は元ファイルのロジックをできるだけ保持しています。
let DATA = []; let DATA_UPDATED_AT = null; let currentSelected = null; let chart = null;
const rankListEl = document.getElementById('rankList');
const sortModeEl = document.getElementById('sortMode');
const searchEl = document.getElementById('search');
const scopeEl = document.getElementById('scope');
const groupFilterEl = document.getElementById('groupFilter');
const clearBtn = document.getElementById('clearGroups');
const ctx = document.getElementById('trendChart').getContext('2d');

// 以下の関数群は元ファイルの算出ロジックをそのまま利用しています（predict, preprocess, ema, etc）。
// 実運用では元ファイルと完全一致させてください。ここは要点だけ簡潔に記載します。

function floorToHalfHour(date){const d=new Date(date);d.setSeconds(0,0);const m=d.getMinutes(); if(m===0||m===30) return d; if(m<30){d.setMinutes(0); return d;} d.setMinutes(30); return d;}

function preprocessHistory(history){ if(!Array.isArray(history)) return []; const pts=history.map(h=>{const t=h.datetime?new Date(h.datetime):(h.date?new Date(h.date+'T00:00:00.000Z'):null); if(!t) return null; return {t:t, tsMin:t.getTime()/60000, v:(h.views||0)};}).filter(x=>!!x); pts.sort((a,b)=>a.t.getTime()-b.t.getTime()); const unique=[]; for(const p of pts){ const last=unique[unique.length-1]; if(last && Math.abs(last.tsMin-p.tsMin)<1e-6) unique[unique.length-1]=p; else unique.push(p);} return unique; }
function median(arr){ if(!arr||arr.length===0) return 0; const s=arr.slice().sort((a,b)=>a-b); const m=Math.floor(s.length/2); if(s.length%2===1) return s[m]; return (s[m-1]+s[m])/2; }
function mad(arr){ if(!arr||arr.length===0) return 0; const med=median(arr); const abs=arr.map(x=>Math.abs(x-med)); return median(abs); }
function emaOfRates(rates, alpha){ if(!rates||rates.length===0) return 0; let s=rates[0]; for(let i=1;i<rates.length;i++){ s=alpha*rates[i]+(1-alpha)*s; } return s; }

function computeAdvancedSlope(history){ const pts=preprocessHistory(history); const n=pts.length; if(n<2) return {slope_reg:0,slope_ema:0,slope_final:0,r2:0,nPoints:n,medRate:0}; const segRates=[]; for(let i=0;i<pts.length-1;i++){ const dv=pts[i+1].v-pts[i].v; const dt=pts[i+1].tsMin-pts[i].tsMin; if(dt<=0) continue; segRates.push(dv/dt);} if(segRates.length===0) return {slope_reg:0,slope_ema:0,slope_final:0,r2:0,nPoints:n,medRate:0}; const medRate=median(segRates); const madRate=mad(segRates)||1e-6; const OUTLIER_K=6; const goodIdx=[]; for(let i=0;i<pts.length;i++){ let ok=true; if(i<pts.length-1){ const r=(pts[i+1].v-pts[i].v)/Math.max(0.0001,(pts[i+1].tsMin-pts[i].tsMin)); if(Math.abs(r-medRate)>OUTLIER_K*madRate) ok=false; } if(i>0){ const r2=(pts[i].v-pts[i-1].v)/Math.max(0.0001,(pts[i].tsMin-pts[i-1].tsMin)); if(Math.abs(r2-medRate)>OUTLIER_K*madRate) ok=false; } if(ok) goodIdx.push(i);} const goodPts=goodIdx.map(i=>pts[i]); if(goodPts.length<2) goodPts.splice(0,goodPts.length,...pts); const last=goodPts[goodPts.length-1]; const refTs=last.tsMin; const xs=goodPts.map(p=>p.tsMin-refTs); const ys=goodPts.map(p=>p.v); const HALF_LIFE_MIN=180; const ln2=Math.log(2); const ws=xs.map(x=>Math.exp(-(Math.abs(x)/HALF_LIFE_MIN)*ln2)); let S=0,Sx=0,Sy=0,Sxx=0,Sxy=0; for(let i=0;i<xs.length;i++){ const w=ws[i]; const x=xs[i]; const y=ys[i]; S+=w; Sx+=w*x; Sy+=w*y; Sxx+=w*x*x; Sxy+=w*x*y; } const denom=(S*Sxx-Sx*Sx); let slope_reg=0, intercept=0; if(Math.abs(denom)>1e-9){ slope_reg=(S*Sxy-Sx*Sy)/denom; intercept=(Sy-slope_reg*Sx)/S; } else { const totalDv=ys[ys.length-1]-ys[0]; const totalDt=(goodPts[goodPts.length-1].tsMin-goodPts[0].tsMin)||1; slope_reg=totalDv/totalDt; intercept=ys[ys.length-1]-slope_reg*xs[xs.length-1]; } let SSres=0,SStot=0; const yWeightedMean=Sy/S; for(let i=0;i<xs.length;i++){ const w=ws[i]; const x=xs[i]; const y=ys[i]; const yhat=intercept+slope_reg*x; SSres+=w*Math.pow(y-yhat,2); SStot+=w*Math.pow(y-yWeightedMean,2); } let r2=0; if(SStot>1e-9) r2=Math.max(0,1-(SSres/SStot)); if(!isFinite(r2)||r2<0) r2=0; const instRates=[]; for(let i=0;i<pts.length-1;i++){ const dv=pts[i+1].v-pts[i].v; const dt=pts[i+1].tsMin-pts[i].tsMin; if(dt<=0) continue; instRates.push(dv/dt);} const alpha=0.5; const slope_ema=emaOfRates(instRates,alpha); const nEff=Math.min(6,xs.length); let conf=r2*(nEff/6); if(conf<0) conf=0; if(conf>1) conf=1; let slope_final=conf*slope_reg+(1-conf)*slope_ema; if(!isFinite(slope_final)||slope_final<0) slope_final=Math.max(0,slope_ema,slope_reg,0); const maxMultiplier=10; const cap=Math.max(Math.abs(medRate)*maxMultiplier,1); if(Math.abs(slope_final)>cap) slope_final=Math.sign(slope_final)*cap; return {slope_reg,slope_ema,slope_final,r2,nPoints:pts.length,medRate}; }

function predictValueAt(history,targetDate){ if(!history||history.length===0) return 0; const last=history[history.length-1]; const lastTime= last.datetime?new Date(last.datetime):(last.date?new Date(last.date+'T00:00:00.000Z'):null); const lastViews= last.views||0; if(!lastTime) return lastViews; const slopeInfo=computeAdvancedSlope(history); const slope=slopeInfo.slope_final||0; const deltaMin=(targetDate.getTime()-lastTime.getTime())/60000; let pred=lastViews + slope*deltaMin; if(!isFinite(pred)) pred=lastViews; if(pred<0) pred=0; return Math.round(pred); }

function earliestHistoryTime(history){ if(!history||history.length===0) return null; const first=history[0]; const t= first.datetime?new Date(first.datetime):(first.date?new Date(first.date+'T00:00:00.000Z'):null); return t; }

function calcDeltaWithPrediction(history,days){ if(!history||history.length===0) return 0; const now=new Date(); const nowPred=predictValueAt(history,now); const target=new Date(now.getTime()-days*24*60*60*1000); const targetTick=floorToHalfHour(target); const firstTime=earliestHistoryTime(history); let baseTick; if(!firstTime) baseTick=targetTick; else{ const firstTick=floorToHalfHour(firstTime); if(targetTick.getTime()<firstTick.getTime()) baseTick=firstTick; else baseTick=targetTick;} const basePred=predictValueAt(history,baseTick); return Math.max(0, nowPred-basePred); }

/* --- データ読み込み / ランキング描画 --- */
let _lastTopPicks = { new: null, week: null, month: null, total: null };

async function loadData(){ try{ const res = await fetch('data/videos.json', { cache: 'no-store' }); if(!res.ok) throw new Error('data/videos.json が見つかりません: ' + res.status); const json = await res.json(); DATA = json.videos || []; DATA_UPDATED_AT = json.updated_at || null; const lastEl=document.getElementById('lastUpdated'); if(lastEl){ if(DATA_UPDATED_AT){ const d=new Date(DATA_UPDATED_AT); lastEl.innerText='最終更新: '+d.toLocaleString(); } else lastEl.innerText='最終更新: —'; }
    buildGroupOptions(); renderRankList(); if(currentSelected && currentSelected.videoId){ const fresh = DATA.find(x=>x.videoId===currentSelected.videoId); if(fresh) selectVideo(fresh); else selectDefault(); } else selectDefault(); } catch(err){ console.error(err); if(rankListEl) rankListEl.innerText = 'データ読み込みエラー: ' + err.message; const lastEl=document.getElementById('lastUpdated'); if(lastEl) lastEl.innerText='最終更新: エラー'; } }

function buildGroupOptions(){ groupFilterEl.innerHTML = '<option value="all">グループ: 全て</option>'; const BANNER_ORDER = ["一歌","咲希","穂波","志歩","みのり","遥","愛莉","雫","こはね","杏","彰人","冬弥","司","えむ","寧々","類","奏","まふゆ","絵名","瑞希"]; const UNIT_ORDER = ["レオニ","モモジャン","ビビバス","ワンダショ","ニーゴ"]; if(scopeEl.value === 'banner'){ BANNER_ORDER.forEach(b=> groupFilterEl.insertAdjacentHTML('beforeend', `<option value="${escapeHtml(b)}">${escapeHtml(b)}</option>`)); } else if(scopeEl.value === 'unit'){ UNIT_ORDER.forEach(u=> groupFilterEl.insertAdjacentHTML('beforeend', `<option value="${escapeHtml(u)}">${escapeHtml(u)}</option>`)); } else { groupFilterEl.insertAdjacentHTML('beforeend','<option disabled>--- バナー ---</option>'); BANNER_ORDER.forEach(b=> groupFilterEl.insertAdjacentHTML('beforeend', `<option value="banner:${escapeHtml(b)}">${escapeHtml(b)}</option>`)); groupFilterEl.insertAdjacentHTML('beforeend','<option disabled>--- ユニット ---</option>'); UNIT_ORDER.forEach(u=> groupFilterEl.insertAdjacentHTML('beforeend', `<option value="unit:${escapeHtml(u)}">${escapeHtml(u)}</option>`)); } }

function renderRankList(){ const globalAnnotated = DATA.map(v=>{ const latestPred = predictValueAt(v.history||[], new Date()); const d7 = calcDeltaWithPrediction(v.history||[],7); const d30 = calcDeltaWithPrediction(v.history||[],30); return Object.assign({}, v, { latest: latestPred, d7:d7, d30:d30 }); });

  const topWeekGlobal = globalAnnotated.reduce((acc,cur)=> cur.d7 > (acc.d7||-Infinity)? cur:acc, {});
  const topMonthGlobal = globalAnnotated.reduce((acc,cur)=> cur.d30 > (acc.d30||-Infinity)? cur:acc, {});
  const topTotalGlobal = globalAnnotated.reduce((acc,cur)=> cur.latest > (acc.latest||-Infinity)? cur:acc, {});

  function getPublishDate(v){ if(!v) return null; if(v.published){ const d = parseISOorDateString(v.published); if(d && !isNaN(d.getTime())) return d;} const last = v.history && v.history.length ? v.history[v.history.length-1] : null; if(last){ if(last.datetime) return new Date(last.datetime); if(last.date) return new Date(last.date+'T00:00:00.000Z'); } return null; }

  let topNewGlobal = null; for(const v of globalAnnotated){ const pd = getPublishDate(v); if(!pd) continue; if(!topNewGlobal) topNewGlobal={video:v,date:pd}; else{ if(pd.getTime() > topNewGlobal.date.getTime()) topNewGlobal={video:v,date:pd}; } }

  _lastTopPicks.week = topWeekGlobal && topWeekGlobal.title ? topWeekGlobal : null;
  _lastTopPicks.month = topMonthGlobal && topMonthGlobal.title ? topMonthGlobal : null;
  _lastTopPicks.total = topTotalGlobal && topTotalGlobal.title ? topTotalGlobal : null;
  _lastTopPicks.new = topNewGlobal && topNewGlobal.video ? topNewGlobal.video : null;

  const trendWeekEl = document.getElementById('trendWeek');
  const trendMonthEl = document.getElementById('trendMonth');
  const trendTotalEl = document.getElementById('trendTotal');
  const trendNewEl = document.getElementById('trendNew');

  if(trendWeekEl) trendWeekEl.innerText = _lastTopPicks.week ? `${_lastTopPicks.week.title} — ${fmt(_lastTopPicks.week.d7)} 回` : '—';
  if(trendMonthEl) trendMonthEl.innerText = _lastTopPicks.month ? `${_lastTopPicks.month.title} — ${fmt(_lastTopPicks.month.d30)} 回` : '—';
  if(trendTotalEl) trendTotalEl.innerText = _lastTopPicks.total ? `${_lastTopPicks.total.title} — ${fmt(_lastTopPicks.total.latest)} 回` : '—';
  if(_lastTopPicks.new){ const d = getPublishDate(_lastTopPicks.new) || new Date(); const yyyyMMdd = d.toISOString().slice(0,10); if(trendNewEl) trendNewEl.innerText = `${_lastTopPicks.new.title} — ${yyyyMMdd}`; } else { if(trendNewEl) trendNewEl.innerText = '—'; }

  /* 新: トレンドカードにサムネイルとテキストを注入 */
  function setupTrendItemCard(itemId, video, labelText){ const el = document.getElementById(itemId); if(!el) return; const img = el.querySelector('.trend-thumb'); const titleEl = el.querySelector('.trend-title'); const metaEl = el.querySelector('.trend-meta'); el.onclick = null; el.style.border='1px solid var(--border)'; el.style.background='linear-gradient(180deg,#ffffff,#fbfcff)'; el.removeAttribute('data-video-id'); if(video){ img.src = video.thumbnail || ''; titleEl.textContent = video.title || '（タイトル不明）'; if(labelText) metaEl.textContent = labelText; else metaEl.textContent = `${fmt(predictValueAt(video.history||[], new Date()))} 回`; el.style.cursor='pointer'; el.setAttribute('data-video-id', video.videoId); el.onclick = function(e){ e.stopPropagation(); selectVideo(video); }; } else { img.src=''; titleEl.textContent='—'; metaEl.textContent='—'; el.style.cursor='default'; } }

  setupTrendItemCard('trendItemWeek', _lastTopPicks.week, _lastTopPicks.week ? `▲${fmt(_lastTopPicks.week.d7)} / 7d` : null);
  setupTrendItemCard('trendItemMonth', _lastTopPicks.month, _lastTopPicks.month ? `▲${fmt(_lastTopPicks.month.d30)} / 30d` : null);
  setupTrendItemCard('trendItemTotal', _lastTopPicks.total, _lastTopPicks.total ? `${fmt(_lastTopPicks.total.latest)} 回` : null);
  setupTrendItemCard('trendItemNew', _lastTopPicks.new, _lastTopPicks.new ? `公開: ${_lastTopPicks.new.published || '—'}` : null);

  /* ランキング描画 (元ロジック) */
  const mode = sortModeEl.value; const q = searchEl.value.trim().toLowerCase(); let list = DATA.slice(); const gv = groupFilterEl.value; if(gv && gv !== 'all'){ if(gv.startsWith('banner:')) list = list.filter(v=>v.banner===gv.slice(7)); else if(gv.startsWith('unit:')) list = list.filter(v=>v.unit===gv.slice(5)); else{ if(scopeEl.value==='banner') list = list.filter(v=>v.banner===gv); if(scopeEl.value==='unit') list = list.filter(v=>v.unit===gv); } }
  if(q) list = list.filter(v=> (v.title||'').toLowerCase().includes(q) || (v.banner||'').toLowerCase().includes(q) || (v.unit||'').toLowerCase().includes(q));

  const annotated = list.map(v=>{ const latestPred = predictValueAt(v.history||[], new Date()); const d7 = calcDeltaWithPrediction(v.history||[],7); const d30 = calcDeltaWithPrediction(v.history||[],30); return Object.assign({}, v, { latest: latestPred, d7:d7, d30:d30 }); });

  if(mode==='total'){ annotated.sort((a,b)=>b.latest - a.latest); } else if(mode==='published'){ annotated.sort((a,b)=>{ const da = parseISOorDateString(a.published) || (a.history&&a.history.length? new Date(a.history[a.history.length-1].datetime||a.history[a.history.length-1].date+'T00:00:00.000Z'):null); const db = parseISOorDateString(b.published) || (b.history&&b.history.length? new Date(b.history[b.history.length-1].datetime||b.history[b.history.length-1].date+'T00:00:00.000Z'):null); const ta = da?da.getTime():0; const tb = db?db.getTime():0; return tb-ta; }); }

  rankListEl.innerHTML = '';
  if(annotated.length===0){ rankListEl.innerHTML = '<div style="padding:12px;color:var(--text-muted)">該当する動画がありません。</div>'; return; }

  annotated.forEach((v, idx)=>{ const li = document.createElement('div'); li.className='video-item'; if(currentSelected && currentSelected.videoId===v.videoId) li.classList.add('active'); li.innerHTML = `<div class="rank-num">${idx+1}</div><img class="thumb" src="${escapeHtml(v.thumbnail||'')}" alt="thumb"><div class="meta"><div class="title">${escapeHtml(v.title)}</div><div class="tags"><div class="badge banner-badge">${escapeHtml(v.banner)}</div><div class="badge unit-badge">${escapeHtml(v.unit)}</div></div><div style="display:flex;justify-content:space-between;margin-top:6px;font-size:0.8rem;color:var(--text-muted)"><span>${fmt(v.latest)} 回</span><span>▲${fmt(v.d7)} / 7d</span></div></div>`; 

    const bannerBadge = li.querySelector('.banner-badge'); if(bannerBadge){ const bannerHex = (v.banner && BANNER_COLORS[v.banner])?BANNER_COLORS[v.banner]:'#e2e8f0'; bannerBadge.style.backgroundColor = mixWithWhite(bannerHex); bannerBadge.style.color = '#1e293b'; bannerBadge.classList.add('clickable'); bannerBadge.addEventListener('click', function(e){ e.stopPropagation(); scopeEl.value='all'; buildGroupOptions(); try{ groupFilterEl.value='banner:'+v.banner; }catch(e){} renderRankList(); rankListEl.scrollTop = 0; }); }

    const unitBadge = li.querySelector('.unit-badge'); if(unitBadge){ const unitHex = (v.unit && UNIT_COLORS[v.unit])?UNIT_COLORS[v.unit]:'#e2e8f0'; unitBadge.style.backgroundColor = mixWithWhite(unitHex); unitBadge.style.color = '#1e293b'; unitBadge.classList.add('clickable'); unitBadge.addEventListener('click', function(e){ e.stopPropagation(); scopeEl.value='all'; buildGroupOptions(); try{ groupFilterEl.value='unit:'+v.unit; }catch(e){} renderRankList(); rankListEl.scrollTop = 0; }); }

    li.addEventListener('click', ()=> selectVideo(v)); rankListEl.appendChild(li);
  });
}

function selectVideo(v){ const vid = (typeof v === 'object' && v.videoId)? v.videoId : (typeof v === 'string'? v: null); let fresh; if(vid) fresh = DATA.find(x=>x.videoId===vid); if(!fresh && typeof v==='object') fresh = v; currentSelected = fresh || null; if(!currentSelected) return; const allItems = document.querySelectorAll('.video-item'); allItems.forEach(el=>el.classList.remove('active'));
  const items = Array.from(document.querySelectorAll('.video-item')); for(const it of items){ const titleEl = it.querySelector('.title'); if(titleEl && titleEl.textContent===currentSelected.title){ it.classList.add('active'); break; } }
  const titleEl = document.getElementById('selectedTitle'); if(titleEl) titleEl.innerText = currentSelected.title || '（動画を選択してください）'; const metaEl = document.getElementById('selectedMeta'); if(metaEl) metaEl.innerHTML = `<a href="${currentSelected.url || '#'}" target="_blank" style="color:var(--primary);text-decoration:none;">YouTubeで見る →</a>`;
  const now = new Date(); const predNow = predictValueAt(currentSelected.history||[], now);
  const selViewsEl = document.getElementById('selectedViews'); if(selViewsEl) selViewsEl.innerText = fmt(predNow) + ' 回'; const viewDelta7El = document.getElementById('viewDelta7'); if(viewDelta7El) viewDelta7El.innerText = fmt(calcDeltaWithPrediction(currentSelected.history||[],7)) + ' 回'; const viewDelta30El = document.getElementById('viewDelta30'); if(viewDelta30El) viewDelta30El.innerText = fmt(calcDeltaWithPrediction(currentSelected.history||[],30)) + ' 回'; const publishDateEl = document.getElementById('publishDate'); if(publishDateEl) publishDateEl.innerText = currentSelected.published || '—';

  const badgesEl = document.getElementById('selectedBadges'); if(badgesEl){ badgesEl.innerHTML=''; if(currentSelected.banner){ const b=document.createElement('div'); b.className='badge clickable'; b.innerText = currentSelected.banner; const color=BANNER_COLORS[currentSelected.banner]||'#e2e8f0'; b.style.background = mixWithWhite(color); b.style.color='#1e293b'; b.addEventListener('click',(e)=>{ e.stopPropagation(); scopeEl.value='all'; buildGroupOptions(); try{ groupFilterEl.value='banner:'+currentSelected.banner;}catch(e){} renderRankList(); }); badgesEl.appendChild(b);} if(currentSelected.unit){ const u=document.createElement('div'); u.className='badge clickable'; u.innerText=currentSelected.unit; const color=UNIT_COLORS[currentSelected.unit]||'#e2e8f0'; u.style.background = mixWithWhite(color); u.style.color='#1e293b'; u.addEventListener('click',(e)=>{ e.stopPropagation(); scopeEl.value='all'; buildGroupOptions(); try{ groupFilterEl.value='unit:'+currentSelected.unit;}catch(e){} renderRankList(); }); badgesEl.appendChild(u);} }

  drawChartForSelection(document.querySelector('.tab-mode.active')?document.querySelector('.tab-mode.active').dataset.period:'all');
}

function drawChartForSelection(period){ if(!currentSelected) return; const hist = currentSelected.history||[]; if(hist.length===0){ if(chart){ chart.destroy(); chart=null;} if(ctx) ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height); return; }
  const now = new Date(); let startTime; if(period==='7') startTime = new Date(now.getTime()-7*24*60*60*1000); else if(period==='30') startTime = new Date(now.getTime()-30*24*60*60*1000); else{ const firstRec = hist[0]; const firstT = firstRec ? (firstRec.datetime? new Date(firstRec.datetime):(firstRec.date? new Date(firstRec.date+'T00:00:00.000Z'):null)) : null; if(firstT && !isNaN(firstT.getTime())) startTime = new Date(firstT); else startTime = new Date(now.getTime()-30*24*60*60*1000);} if(startTime>now) startTime = new Date(now.getTime()); let t0 = floorToHalfHour(startTime); if(t0>now) t0 = floorToHalfHour(now);
  const ticks=[]; const thirtyMin = 30*60*1000; for(let t=new Date(t0.getTime()); t.getTime()<= now.getTime(); t = new Date(t.getTime()+thirtyMin)){ ticks.push(new Date(t.getTime())); if(ticks.length>2000) break;} if(ticks.length===0|| Math.abs(ticks[ticks.length-1].getTime()-now.getTime())>1000) ticks.push(new Date(now.getTime())); const labels=[]; const data=[]; const timesFull=[]; for(const t of ticks){ const pred = predictValueAt(hist,t); labels.push(formatLabelForTick(t, period)); data.push(pred); timesFull.push(t.toLocaleString()); }
  const banner = currentSelected.banner; let colorHex = (banner && banner!=='-' && BANNER_COLORS[banner])?BANNER_COLORS[banner]:(UNIT_COLORS[currentSelected.unit]||'#3b82f6'); const areaColor = hexToRgba(colorHex,0.12); const lineColor = colorHex;
  if(chart){ chart.data.labels = labels; chart.data.datasets[0].data = data; chart.data.datasets[0].backgroundColor = areaColor; chart.data.datasets[0].borderColor = lineColor; chart.data.datasets[0].timesFull = timesFull; chart.update('none'); } else { if(!ctx) return; chart = new Chart(ctx,{ type:'line', data:{ labels:labels, datasets:[{ label: currentSelected.title, data:data, tension:0.2, fill:true, backgroundColor:areaColor, borderColor:lineColor, pointRadius:2, pointHoverRadius:4, timesFull:timesFull }] }, options:{ responsive:true, maintainAspectRatio:false, interaction:{mode:'nearest', intersect:false}, layout:{padding:{left:0,right:0,top:10,bottom:0}}, scales:{ x:{ display:true, grid:{display:false}, ticks:{color:'#94a3b8', font:{size:10}, autoSkip:true, maxRotation:0, minRotation:0} }, y:{ display:true, grid:{color:'#f1f5f9'}, ticks:{color:'#94a3b8', font:{size:10}, callback:function(v){ return Intl.NumberFormat().format(v); } }, beginAtZero:false } }, plugins:{ legend:{display:false}, tooltip:{ backgroundColor:'rgba(255,255,255,0.95)', titleColor:'#0f172a', bodyColor:'#0f172a', borderColor:'#e2e8f0', borderWidth:1, padding:10, callbacks:{ title:function(items){ if(!items||!items.length) return ''; const it=items[0]; const ds = chart.data.datasets[it.datasetIndex]; if(ds && Array.isArray(ds.timesFull) && ds.timesFull[it.dataIndex]) return ds.timesFull[it.dataIndex]; return chart.data.labels[it.dataIndex]||''; }, label:function(context){ return '推定 ' + Intl.NumberFormat().format(context.parsed.y) + ' 回'; } } } } } }); }
  const selViews = document.getElementById('selectedViews'); if(selViews) selViews.innerText = Intl.NumberFormat().format(predictValueAt(hist, new Date())) + ' 回'; }

function formatLabelForTick(date, period){ const daysSpan = (function(){ if(period==='7') return 7; if(period==='30') return 30; return 3; })(); if(daysSpan>1){ const m=String(date.getMonth()+1); const d=String(date.getDate()); return `${m}/${d}`;} else { const hh=String(date.getHours()).padStart(2,'0'); const mm=String(date.getMinutes()).padStart(2,'0'); return `${hh}:${mm}`; } }

/* イベントバインド */
if(clearBtn) clearBtn.addEventListener('click', function(){ scopeEl.value='all'; buildGroupOptions(); try{ groupFilterEl.value='all'; }catch(e){} renderRankList(); });
sortModeEl.addEventListener('change', renderRankList); searchEl.addEventListener('input', renderRankList); scopeEl.addEventListener('change', function(){ buildGroupOptions(); renderRankList(); }); groupFilterEl.addEventListener('change', renderRankList);

document.querySelectorAll('.tab-mode').forEach(btn=>{ btn.addEventListener('click', function(){ document.querySelectorAll('.tab-mode').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); drawChartForSelection(btn.dataset.period); }); });

function selectDefault(){ if(DATA.length){ const sorted=DATA.slice().sort((a,b)=>{ const la=predictValueAt(a.history||[], new Date()); const lb=predictValueAt(b.history||[], new Date()); return lb-la; }); selectVideo(sorted[0]); } }

loadData();
const TWENTY_MIN = 20*60*1000; setInterval(()=>{ loadData(); }, TWENTY_MIN);

/* header spacer */
function adjustHeaderSpacer(){ const header=document.querySelector('header'); const spacer=document.getElementById('headerSpacer'); if(!header||!spacer) return; const rect = header.getBoundingClientRect(); spacer.style.height = Math.ceil(rect.height + 10) + 'px'; }
window.addEventListener('resize', adjustHeaderSpacer); window.addEventListener('orientationchange', adjustHeaderSpacer); document.addEventListener('DOMContentLoaded', adjustHeaderSpacer); setTimeout(adjustHeaderSpacer, 50);

</script>
</body>
</html>
