<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>YouTube 再生数ランキング & トレンド ダッシュボード</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root{
      /* 白背景に合わせた配色 */
      --bg: #ffffff;
      --card: #ffffff;
      --muted: #596274;
      --text: #111827;
      --accent:#2563eb;
      --glass: rgba(15,23,42,0.03);
      --card-radius:12px;
      font-family: Inter, system-ui, "Hiragino Kaku Gothic ProN", "Yu Gothic", "Meiryo", sans-serif;
      color: var(--text);
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text);}
    .wrap{max-width:1200px;margin:28px auto;padding:20px;}
    /* Header stays mostly the same, but center the search visually */
    header{display:flex;gap:18px;align-items:center;justify-content:space-between;margin-bottom:18px;}
    header .title{font-size:20px;color:var(--text); font-weight:700;}
    .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .card{
      background:var(--card);
      border-radius:var(--card-radius);
      padding:14px;
      box-shadow: 0 6px 18px rgba(15,23,42,0.06);
      border: 1px solid rgba(15,23,42,0.04);
    }
    /* three-column layout (left: trend, center: main graph, right: ranking) */
    .grid{display:grid;grid-template-columns: 240px 1fr 240px;gap:16px;}
    select, button, input[type="search"]{
      background:#f7f9fb; border:1px solid rgba(15,23,42,0.06); color:var(--text); padding:8px 10px;border-radius:8px;
      font-size:13px;
    }
    select:focus, input[type="search"]:focus, button:focus{ outline: 2px solid rgba(37,99,235,0.12); outline-offset:2px; }
    button.primary{background:linear-gradient(90deg,#3b82f6,#60a5fa); color:#fff; font-weight:700; border:none; padding:9px 12px;}
    .rank-list{display:flex;flex-direction:column;gap:8px; max-height:520px; overflow:auto; padding-right:6px;}
    .video-item{display:flex;gap:10px;align-items:center;padding:8px;border-radius:10px;cursor:pointer;transition:background .12s, transform .06s}
    .video-item:hover{background:rgba(37,99,235,0.03); transform: translateY(-2px);}
    /* thumbnails smaller as requested */
    .thumb{width:64px;height:40px;border-radius:6px;background:#eee;flex:0 0 64px;object-fit:cover;border:1px solid rgba(15,23,42,0.04);}
    .meta{flex:1;min-width:0;}
    .meta .title{font-size:13px;color:var(--text);font-weight:600;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;}
    .meta .sub{font-size:12px;color:var(--muted);display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
    .badge{padding:4px 8px;border-radius:999px;font-size:12px;background:#f1f5f9;color:var(--muted);border:1px solid rgba(15,23,42,0.03)}
    .badge.clickable{cursor:pointer;}
    .rank-num{font-size:14px;color:var(--accent);width:28px;text-align:center;font-weight:700}
    .stats-row{display:flex;gap:8px;align-items:center; justify-content:flex-end;}
    .big-card{padding:16px;}
    .chart-area{height:320px;}
    .tabs{display:flex;gap:8px;margin-bottom:12px;}
    .tabs button{background:transparent;border:1px solid rgba(15,23,42,0.04);padding:8px 12px;border-radius:8px;color:var(--muted);cursor:pointer;}
    .tabs button.active{background:linear-gradient(90deg, rgba(37,99,235,0.08), rgba(37,99,235,0.04)); color:var(--text);border-color:transparent;}
    .top-metrics{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .metric{background:linear-gradient(180deg, rgba(15,23,42,0.02), rgba(15,23,42,0.01)); padding:8px;border-radius:10px; min-width:120px; border:1px solid rgba(15,23,42,0.04); flex:0 1 auto; display:flex;flex-direction:column;justify-content:center;}
    .metric .label{font-size:12px;color:var(--muted)}
    .metric .val{font-size:16px;color:var(--text);font-weight:700}
    .footer-note{font-size:12px;color:var(--muted);margin-top:8px}
    /* trend list */
    .trend-list{display:flex;flex-direction:column;gap:12px;}
    .trend-item{Padding:12px;border-radius:10px;border:1px solid rgba(15,23,42,0.04);background:linear-gradient(180deg, rgba(15,23,42,0.01), rgba(15,23,42,0.00));}
    .trend-item .label{font-size:13px;color:var(--muted);margin-bottom:6px;}
    .trend-item .val{font-weight:700;color:var(--text);}
    /* responsive */
    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr; }
      .thumb{width:100px; height:56px; flex:0 0 100px;}
      .metric{min-width:100px; font-size:13px;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <div class="title">YouTube 再生数ランキング & トレンド</div>
        <div class="subtitle" style="font-size:13px;color:var(--muted)">
          <div id="lastUpdated" style="margin-top:6px;font-size:12px;color:var(--muted)">最終更新: 読み込み中...</div>
        </div>
      </div>
      <div class="controls">
        <input id="search" type="search" placeholder="タイトル / バナー / ユニット で検索">
        <select id="scope">
          <option value="all">全体</option>
          <option value="banner">バナー別</option>
          <option value="unit">ユニット別</option>
        </select>
        <select id="groupFilter"><option value="all">グループ: 全て</option></select>
        <button id="clearGroups" class="primary">グループ分けクリア</button>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT COLUMN: trend information -->
      <div>
        <div class="card">
          <strong style="color:var(--text)">トレンド情報</strong>
          <div style="margin-top:10px" class="trend-list">
            <div class="trend-item" id="trendItemNew">
              <div class="label">新着動画</div>
              <div id="trendNew" class="val">—</div>
            </div>
            <div class="trend-item" id="trendItemWeek">
              <div class="label">直近1週間で再生数伸びトップ</div>
              <div id="trendWeek" class="val">—</div>
            </div>
            <div class="trend-item" id="trendItemMonth">
              <div class="label">直近1ヶ月で再生数伸びトップ</div>
              <div id="trendMonth" class="val">—</div>
            </div>
            <div class="trend-item" id="trendItemTotal">
              <div class="label">累計再生数トップ</div>
              <div id="trendTotal" class="val">—</div>
            </div>
          </div>
        </div>

      </div>

      <!-- CENTER COLUMN: graph / details -->
      <div>
        <div class="card big-card">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div>
              <div id="selectedTitle" style="font-weight:700;font-size:16px;color:var(--text)">（動画を選択してください）</div>
              <div id="selectedMeta" style="font-size:13px;color:var(--muted);margin-top:6px">—</div>
            </div>
            <div class="stats-row">
              <!-- This area used to show 最新再生回数; changed to display unit & banner badges per request -->
              <div id="selectedBadges" style="display:flex;gap:6px;align-items:center;">
                <!-- badges will be injected here -->
              </div>
            </div>
          </div>

          <div style="margin-top:14px;" class="tabs">
            <button class="tab-mode active" data-period="all">全期間推移</button>
            <button class="tab-mode" data-period="30">直近30日</button>
            <button class="tab-mode" data-period="7">直近7日</button>
          </div>

          <div class="chart-area card" style="padding:12px;">
            <canvas id="trendChart" style="width:100%;height:320px"></canvas>
            <!-- bottom info removed as requested (do not display tapped date/value) -->
          </div>

          <!-- Four metrics placed inline (one line): 最新再生回数, 直近7日増分, 直近30日増分, 投稿日 -->
          <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:nowrap;align-items:center;">
            <div class="metric card" style="min-width:150px; padding:8px;">
              <div class="label">最新再生数</div>
              <div id="selectedViews" class="val">—</div>
            </div>
            <div class="metric card" style="min-width:150px; padding:8px;">
              <div class="label">直近7日増分</div>
              <div id="viewDelta7" class="val">—</div>
            </div>
            <div class="metric card" style="min-width:150px; padding:8px;">
              <div class="label">直近30日増分</div>
              <div id="viewDelta30" class="val">—</div>
            </div>
            <div class="metric card" style="min-width:150px; padding:8px;">
              <div class="label">投稿日</div>
              <div id="publishDate" class="val">—</div>
            </div>
          </div>
        </div>

      </div>

      <!-- RIGHT COLUMN: ranking -->
      <div>
        <div class="card">
          <div style="display:flex;align-items:center;justify-content:space-between;">
            <strong style="color:var(--text)">ランキング</strong>
            <div style="font-size:13px;color:var(--muted)">並び替え:
              <select id="sortMode">
                <option value="total">累計再生数（降順）</option>
                <option value="published">投稿日（新しい順）</option>
              </select>
            </div>
          </div>

          <div style="margin-top:12px;" class="rank-list card" id="rankList">
            読み込み中...
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* --- helper --- */
function fmt(n){ return n === null || n === undefined ? '—' : n.toLocaleString(); }
function safe(s){ return String(s||''); }
function parseISOorDateString(s){
  if(!s) return null;
  // accepts "YYYY-MM-DD" or full ISO
  if(/^\d{4}-\d{2}-\d{2}$/.test(s)) return new Date(s + 'T00:00:00.000Z');
  return new Date(s);
}

/* format an ISO-ish string to browser-local string (toLocaleString)
   Previously this forced UTC output; changed to local to match header's toLocaleString display.
*/
function formatRecordedTime(iso){
  if(!iso) return '—';
  // if it's only a date like "YYYY-MM-DD", treat as midnight UTC (legacy)
  let asIso = String(iso);
  if(/^\d{4}-\d{2}-\d{2}$/.test(asIso)) asIso = asIso + 'T00:00:00.000Z';
  try {
    const d = new Date(asIso);
    if(isNaN(d.getTime())) return iso;
    // use browser locale so it matches new Date(...).toLocaleString() used for header
    return d.toLocaleString();
  } catch(e){
    return iso;
  }
}

/* --- Banner color mapping (expanded 3-digit hex to full 6-digit) --- */
const BANNER_COLORS = {
  "一歌": "#33AAEE",
  "咲希": "#FFDD44",
  "穂波": "#EE6666",
  "志歩": "#BBDD22",
  "みのり": "#FFCCAA",
  "遥":   "#99CCFF",
  "愛莉": "#FFAACC",
  "雫":   "#99EEDD",
  "こはね": "#FF6699",
  "杏":   "#00BBDD",
  "彰人": "#FF7722",
  "冬弥": "#0077DD",
  "司":   "#FFBB00",
  "えむ": "#FF66BB",
  "寧々": "#33DD99",
  "類":   "#BB88EE",
  "奏":   "#BB6688",
  "まふゆ": "#8888CC",
  "絵名": "#CCAA88",
  "瑞希": "#DDAACC"
};

/* --- Unit fallback colors (expanded) --- */
const UNIT_COLORS = {
  "レオニ": "#4455DD",
  "モモジャン": "#88DD44",
  "ビビバス": "#EE1166",
  "ワンダショ": "#FF9900",
  "ニーゴ": "#884499"
};

/* convert hex color (#RRGGBB) to rgba string with alpha */
function hexToRgba(hex, alpha){
  if(!hex) return `rgba(37,99,235,${alpha})`;
  hex = hex.replace('#','');
  if(hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
  const r = parseInt(hex.slice(0,2),16);
  const g = parseInt(hex.slice(2,4),16);
  const b = parseInt(hex.slice(4,6),16);
  return `rgba(${r},${g},${b},${alpha})`;
}

/* mix provided hex color with white (#FFFFFF) in ratio 1:2 (1 color + 2 white) and return hex */
function mixWithWhite(hex){
  if(!hex) hex = '#2563eb';
  hex = hex.replace('#','');
  if(hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
  const r = parseInt(hex.slice(0,2),16);
  const g = parseInt(hex.slice(2,4),16);
  const b = parseInt(hex.slice(4,6),16);
  // mix: (color * 1 + white * 2) / 3 -> white components are 255
  const mr = Math.round((r + 2*255)/3);
  const mg = Math.round((g + 2*255)/3);
  const mb = Math.round((b + 2*255)/3);
  return '#' + [mr,mg,mb].map(n=> n.toString(16).padStart(2,'0')).join('');
}

/* mix provided hex color with white (#FFFFFF) in ratio 1:W (1 color + W white) and return hex */
function mixWithWhiteRatio(hex, whiteParts){
  if(!hex) hex = '#2563eb';
  if(!whiteParts || whiteParts < 0) whiteParts = 4;
  hex = hex.replace('#','');
  if(hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
  const r = parseInt(hex.slice(0,2),16);
  const g = parseInt(hex.slice(2,4),16);
  const b = parseInt(hex.slice(4,6),16);
  const total = 1 + whiteParts;
  const mr = Math.round((r + whiteParts*255)/total);
  const mg = Math.round((g + whiteParts*255)/total);
  const mb = Math.round((b + whiteParts*255)/total);
  return '#' + [mr,mg,mb].map(n=> n.toString(16).padStart(2,'0')).join('');
}

/* --- load data/videos.json --- */
let DATA = [];
let DATA_UPDATED_AT = null;
async function loadData(){
  try{
    const res = await fetch('data/videos.json', {cache: "no-store"});
    if(!res.ok) throw new Error('data/videos.json が見つかりません: ' + res.status);
    const json = await res.json();
    DATA = json.videos || [];
    DATA_UPDATED_AT = json.updated_at || null;
    // show last updated in header
    const lastEl = document.getElementById('lastUpdated');
    if(DATA_UPDATED_AT){
      const d = new Date(DATA_UPDATED_AT);
      lastEl.innerText = '最終更新: ' + d.toLocaleString();
    } else {
      lastEl.innerText = '最終更新: —';
    }

    buildGroupOptions();
    renderRankList();

    // preserve selection across reloads: if user had selected a video, re-select latest data for it
    if(currentSelected && currentSelected.videoId){
      const fresh = DATA.find(x=>x.videoId === currentSelected.videoId);
      if(fresh){
        // re-select fresh object (this updates latest metrics and redraws chart)
        selectVideo(fresh);
      } else {
        // if not found, choose default
        selectDefault();
      }
    } else {
      selectDefault();
    }

  }catch(err){
    console.error(err);
    document.getElementById('rankList').innerText = 'データ読み込みエラー: ' + err.message;
    const lastEl = document.getElementById('lastUpdated');
    lastEl.innerText = '最終更新: エラー';
  }
}

/* --- UI state and utilities --- */
const rankListEl = document.getElementById('rankList');
const sortModeEl = document.getElementById('sortMode');
const searchEl = document.getElementById('search');
const scopeEl = document.getElementById('scope');
const groupFilterEl = document.getElementById('groupFilter');
const clearBtn = document.getElementById('clearGroups');

/* --- Group ordering --- */
const BANNER_ORDER = [
  "一歌","咲希","穂波","志歩","みのり","遥","愛莉","雫","こはね","杏","彰人","冬弥","司","えむ","寧々","類","奏","まふゆ","絵名","瑞希"
];
const UNIT_ORDER = ["レオニ","モモジャン","ビビバス","ワンダショ","ニーゴ"];

function buildGroupOptions(){
  groupFilterEl.innerHTML = '<option value="all">グループ: 全て</option>';

  if(scopeEl.value === 'banner'){
    BANNER_ORDER.forEach(b => {
      groupFilterEl.insertAdjacentHTML('beforeend', `<option value="${escapeHtml(b)}">${escapeHtml(b)}</option>`);
    });
  } else if(scopeEl.value === 'unit'){
    UNIT_ORDER.forEach(u => {
      groupFilterEl.insertAdjacentHTML('beforeend', `<option value="${escapeHtml(u)}">${escapeHtml(u)}</option>`);
    });
  } else {
    groupFilterEl.insertAdjacentHTML('beforeend', '<option disabled>--- バナー ---</option>');
    BANNER_ORDER.forEach(b => groupFilterEl.insertAdjacentHTML('beforeend', `<option value="banner:${escapeHtml(b)}">${escapeHtml(b)}</option>`));
    groupFilterEl.insertAdjacentHTML('beforeend', '<option disabled>--- ユニット ---</option>');
    UNIT_ORDER.forEach(u => groupFilterEl.insertAdjacentHTML('beforeend', `<option value="unit:${escapeHtml(u)}">${escapeHtml(u)}</option>`));
  }
}

function escapeHtml(s){ return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

/* --- history utilities using datetime --- */
function lastHistoryEntry(history){
  if(!history || history.length===0) return null;
  return history[history.length-1];
}

function findClosestBefore(history, targetDate){
  if(!history || history.length===0) return null;
  let candidate = history[0];
  for(const rec of history){
    const t = rec.datetime ? new Date(rec.datetime) : (rec.date ? new Date(rec.date + 'T00:00:00.000Z') : null);
    if(!t) continue;
    if(t <= targetDate) candidate = rec;
    else break;
  }
  return candidate;
}

/* --- 新しい calcDelta 実装（要求どおり: 7/30日前が推定値であればそれを使い、なければ最古の推定値を使う） --- */

/* ceil time to next half-hour mark (if already on exact half hour, keep it) */
function ceilToHalfHour(date){
  const d = new Date(date);
  d.setSeconds(0,0);
  const m = d.getMinutes();
  if(m === 0 || m === 30) return d;
  if(m < 30){
    d.setMinutes(30);
    return d;
  }
  // m > 30
  d.setMinutes(0);
  d.setHours(d.getHours() + 1);
  return d;
}

/* floor time to previous half-hour mark (if already exact, keep it) */
function floorToHalfHour(date){
  const d = new Date(date);
  d.setSeconds(0,0);
  const m = d.getMinutes();
  if(m === 0 || m === 30) return d;
  if(m < 30){
    d.setMinutes(0);
    return d;
  }
  d.setMinutes(30);
  return d;
}

/* preprocess history into sorted points [{t:Date, tsMin:number, v:number}] */
function preprocessHistory(history){
  if(!Array.isArray(history)) return [];
  const pts = history.map(h=>{
    const t = h.datetime ? new Date(h.datetime) : (h.date ? new Date(h.date + 'T00:00:00.000Z') : null);
    if(!t) return null;
    return { t: t, tsMin: t.getTime() / 60000, v: (h.views || 0) };
  }).filter(Boolean);
  pts.sort((a,b)=> a.t.getTime() - b.t.getTime());
  // remove duplicates with same minute (keep last)
  const unique = [];
  for(const p of pts){
    const last = unique[unique.length-1];
    if(last && Math.abs(last.tsMin - p.tsMin) < 1e-6){
      unique[unique.length-1] = p;
    } else unique.push(p);
  }
  return unique;
}

/* compute median of array */
function median(arr){
  if(!arr || arr.length===0) return 0;
  const s = arr.slice().sort((a,b)=>a-b);
  const m = Math.floor(s.length/2);
  if(s.length % 2 === 1) return s[m];
  return (s[m-1] + s[m]) / 2;
}

/* compute MAD (median absolute deviation) */
function mad(arr){
  if(!arr || arr.length===0) return 0;
  const med = median(arr);
  const abs = arr.map(x => Math.abs(x - med));
  return median(abs);
}

/* compute EMA for array of rates (most recent last). alpha between 0..1 */
function emaOfRates(rates, alpha){
  if(!rates || rates.length===0) return 0;
  let s = rates[0];
  for(let i=1;i<rates.length;i++){
    s = alpha * rates[i] + (1 - alpha) * s;
  }
  return s;
}

/* robust weighted linear regression + EMA blending
   Returns object:
   { slope_reg: (views/min), slope_ema: (views/min), slope_final, r2, nPoints, medRate }
*/
function computeAdvancedSlope(history){
  const pts = preprocessHistory(history);
  const n = pts.length;
  if(n < 2) return { slope_reg: 0, slope_ema: 0, slope_final: 0, r2:0, nPoints: n, medRate:0 };

  // compute per-segment instantaneous rates (views per minute)
  const segRates = [];
  for(let i=0;i<pts.length-1;i++){
    const dv = pts[i+1].v - pts[i].v;
    const dt = pts[i+1].tsMin - pts[i].tsMin;
    if(dt <= 0) continue;
    segRates.push(dv / dt);
  }
  if(segRates.length === 0) return { slope_reg: 0, slope_ema: 0, slope_final: 0, r2:0, nPoints: n, medRate:0 };

  const medRate = median(segRates);
  const madRate = mad(segRates) || 1e-6; // avoid zero

  // filter out segments that are extreme outliers ( > med + k * MAD )
  const OUTLIER_K = 6; // strict threshold
  const goodIdx = [];
  for(let i=0;i<pts.length;i++){
    // keep points whose adjacent segment rates are not extreme outliers
    // we'll check the segment to next point (if exists) and segment from prev (if exists)
    let ok = true;
    if(i < pts.length - 1){
      const r = (pts[i+1].v - pts[i].v) / Math.max(0.0001, (pts[i+1].tsMin - pts[i].tsMin));
      if(Math.abs(r - medRate) > OUTLIER_K * madRate) ok = false;
    }
    if(i > 0){
      const r2 = (pts[i].v - pts[i-1].v) / Math.max(0.0001, (pts[i].tsMin - pts[i-1].tsMin));
      if(Math.abs(r2 - medRate) > OUTLIER_K * madRate) ok = false;
    }
    if(ok) goodIdx.push(i);
  }
  // build filtered points
  const goodPts = goodIdx.map(i => pts[i]);
  const m = goodPts.length;
  if(m < 2){
    // if filtering removed too much, use original pts
    goodPts.splice(0, goodPts.length, ...pts);
  }

  // Weighted linear regression on (x: minutes since reference, y: views)
  // reference time: last point time (so x <= 0 for older points). To avoid huge numbers, use delta minutes relative to last point.
  const last = goodPts[goodPts.length - 1];
  const refTs = last.tsMin;
  const xs = goodPts.map(p => p.tsMin - refTs); // negative or zero
  const ys = goodPts.map(p => p.v);

  // weights: exponential decay by age (minutes). half-life parameter tuned to emphasize recent data.
  const HALF_LIFE_MIN = 180; // 3 hours half-life (can be tuned)
  const ln2 = Math.log(2);
  const ws = xs.map(x => Math.exp(- (Math.abs(x) / HALF_LIFE_MIN) * ln2 ));

  // compute weighted sums
  let S=0, Sx=0, Sy=0, Sxx=0, Sxy=0;
  for(let i=0;i<xs.length;i++){
    const w = ws[i];
    const x = xs[i];
    const y = ys[i];
    S += w;
    Sx += w * x;
    Sy += w * y;
    Sxx += w * x * x;
    Sxy += w * x * y;
  }

  const denom = (S * Sxx - Sx * Sx);
  let slope_reg = 0;
  let intercept = 0;
  if(Math.abs(denom) > 1e-9){
    slope_reg = (S * Sxy - Sx * Sy) / denom; // units: views per minute (because x is minutes)
    intercept = (Sy - slope_reg * Sx) / S;
  } else {
    // fallback: use simple average rate
    const totalDv = ys[ys.length-1] - ys[0];
    const totalDt = (goodPts[goodPts.length-1].tsMin - goodPts[0].tsMin) || 1;
    slope_reg = totalDv / totalDt;
    intercept = ys[ys.length-1] - slope_reg * xs[xs.length-1];
  }

  // compute weighted R^2 as measure of fit quality
  // weighted residual sum of squares
  let SSres = 0;
  let SStot = 0;
  const yWeightedMean = Sy / S;
  for(let i=0;i<xs.length;i++){
    const w = ws[i];
    const x = xs[i];
    const y = ys[i];
    const yhat = intercept + slope_reg * x;
    SSres += w * Math.pow(y - yhat, 2);
    SStot += w * Math.pow(y - yWeightedMean, 2);
  }
  let r2 = 0;
  if(SStot > 1e-9) r2 = Math.max(0, 1 - (SSres / SStot));
  // ensure numeric safety
  if(!isFinite(r2) || r2 < 0) r2 = 0;

  // EMA of instantaneous segment rates to capture recent rapid changes
  // use alpha such that recent segments dominate (alpha ~ 0.5)
  const instRates = [];
  for(let i=0;i<pts.length-1;i++){
    const dv = pts[i+1].v - pts[i].v;
    const dt = pts[i+1].tsMin - pts[i].tsMin;
    if(dt <= 0) continue;
    instRates.push(dv / dt);
  }
  // alpha choice: prefer recent segments. If many segments, slightly smaller alpha.
  const alpha = 0.5;
  const slope_ema = emaOfRates(instRates, alpha);

  // confidence: combine R2 and number of good points into 0..1
  const nEff = Math.min(6, xs.length); // use up to 6 points for scaling
  let conf = r2 * (nEff / 6);
  // slightly boost if r2 is very high
  if(conf < 0) conf = 0;
  if(conf > 1) conf = 1;

  // final slope: blend regression and EMA using confidence
  let slope_final = conf * slope_reg + (1 - conf) * slope_ema;

  // sanity caps: no negative slope, and limit to reasonable maximum to avoid crazy jumps
  if(!isFinite(slope_final) || slope_final < 0) slope_final = Math.max(0, slope_ema, slope_reg, 0);
  // limit as a multiple of median segment rate (avoid explosion when medRate ~ 0)
  const maxMultiplier = 10;
  const cap = Math.max(Math.abs(medRate) * maxMultiplier, 1); // at least 1 view/min cap
  if(Math.abs(slope_final) > cap) slope_final = Math.sign(slope_final) * cap;

  return {
    slope_reg,
    slope_ema,
    slope_final,
    r2,
    nPoints: pts.length,
    medRate
  };
}

/* --- Build predicted series anchored at last recorded point.
   Returns array of { t: Date, v: Number } starting from floorToHalfHour(earliestHistTime) up to lastRecTime inclusive,
   step = 30 minutes. If not enough history points, will still return at least one element.
*/
function buildPredictedSeries(history){
  const pts = preprocessHistory(history);
  if(pts.length === 0) return [];

  const lastRec = pts[pts.length - 1];
  const lastRecTime = lastRec.t;
  const lastRecViews = lastRec.v;

  const slopeInfo = computeAdvancedSlope(history);
  const slopePerMin = slopeInfo.slope_final;

  const earliestTime = pts[0].t;
  let t0 = floorToHalfHour(earliestTime);
  // ensure t0 is not after lastRecTime
  if(t0.getTime() > lastRecTime.getTime()) t0 = floorToHalfHour(lastRecTime);

  const series = [];
  const thirtyMin = 30 * 60 * 1000;
  for(let t = new Date(t0.getTime()); t.getTime() <= lastRecTime.getTime(); t = new Date(t.getTime() + thirtyMin)){
    const deltaMin = (t.getTime() - lastRecTime.getTime()) / 60000;
    let pred = Math.round(lastRecViews + slopePerMin * deltaMin);
    if(pred < 0) pred = 0;
    series.push({ t: new Date(t.getTime()), v: pred });
    // safety cap
    if(series.length > 2000) break;
  }
  // ensure at least lastRecTime entry exists (if loop skipped due to t0 > lastRecTime)
  if(series.length === 0){
    series.push({ t: new Date(lastRecTime.getTime()), v: lastRecViews });
  }
  return series;
}

/* --- 新 calcDelta: days (number) -> return last - startValue according to rules:
     1) compute targetTick = floorToHalfHour(lastRecTime - days)
     2) if history contains an entry whose floorToHalfHour(entry.time) == targetTick -> use that entry.views
     3) else build predicted series and:
         - if predicted series contains targetTick -> use that predicted value
         - else use predicted series' earliest value
*/
function calcDelta(history, days){
  if(!history || history.length === 0) return 0;

  // normalize history to points
  const pts = preprocessHistory(history);
  if(pts.length === 0) return 0;

  const lastRec = pts[pts.length - 1];
  const lastRecTime = lastRec.t;
  const lastViews = lastRec.v;

  // compute target tick (floor to half-hour)
  const targetDate = new Date(lastRecTime.getTime() - days * 24 * 60 * 60 * 1000);
  const targetTick = floorToHalfHour(targetDate);

  // 1) check if any actual history entry matches that half-hour slot
  for(const h of history){
    const t = h.datetime ? new Date(h.datetime) : (h.date ? new Date(h.date + 'T00:00:00.000Z') : null);
    if(!t) continue;
    const slot = floorToHalfHour(t);
    if(slot.getTime() === targetTick.getTime()){
      // exact half-hour record found -> use measured views
      const startViews = h.views || 0;
      return Math.max(0, lastViews - startViews);
    }
  }

  // 2) build predicted series (from earliest history half-hour to lastRecTime)
  const predSeries = buildPredictedSeries(history);
  if(predSeries.length === 0){
    // fallback to simple behavior: use earliest recorded history views
    const earliest = pts[0];
    const startViews = earliest ? earliest.v : 0;
    return Math.max(0, lastViews - startViews);
  }

  // try to find predicted entry exactly at targetTick
  let matched = predSeries.find(p => p.t.getTime() === targetTick.getTime());
  if(matched){
    return Math.max(0, lastViews - matched.v);
  }

  // if no exact targetTick in predicted series, check whether targetTick is earlier than earliest predicted tick
  const earliestPred = predSeries[0];
  if(targetTick.getTime() < earliestPred.t.getTime()){
    // use earliest predicted value as requested
    return Math.max(0, lastViews - earliestPred.v);
  }

  // if targetTick is after latest predicted tick (shouldn't happen because predicted series goes to lastRecTime),
  // fallback to nearest earlier predicted
  // find closest before
  let candidate = null;
  for(const p of predSeries){
    if(p.t.getTime() <= targetTick.getTime()) candidate = p;
    else break;
  }
  if(candidate){
    return Math.max(0, lastViews - candidate.v);
  }

  // final fallback: earliest recorded
  const earliestRec = pts[0];
  const startViews = earliestRec ? earliestRec.v : 0;
  return Math.max(0, lastViews - startViews);
}

/* --- render ranking & trend picks --- */
let _lastTopPicks = { new:null, week:null, month:null, total:null };

function renderRankList(){
  const globalAnnotated = DATA.map(v=>{
    const latest = v.history && v.history.length ? (v.history[v.history.length-1].views || 0) : (v.views || 0);
    const d7 = calcDelta(v.history, 7);
    const d30 = calcDelta(v.history, 30);
    return {...v, latest, d7, d30};
  });

  const topWeekGlobal = globalAnnotated.reduce((acc,cur)=> cur.d7 > (acc.d7||-Infinity) ? cur : acc, {});
  const topMonthGlobal = globalAnnotated.reduce((acc,cur)=> cur.d30 > (acc.d30||-Infinity) ? cur : acc, {});
  const topTotalGlobal = globalAnnotated.reduce((acc,cur)=> cur.latest > (acc.latest||-Infinity) ? cur : acc, {});

  function getPublishDate(v){
    if(!v) return null;
    if(v.published){
      const d = parseISOorDateString(v.published);
      if(d && !isNaN(d)) return d;
    }
    const last = v.history && v.history.length ? v.history[v.history.length-1] : null;
    if(last){
      if(last.datetime) return new Date(last.datetime);
      if(last.date) return new Date(last.date + 'T00:00:00.000Z');
    }
    return null;
  }

  let topNewGlobal = null;
  for(const v of globalAnnotated){
    const pd = getPublishDate(v);
    if(!pd) continue;
    if(!topNewGlobal) topNewGlobal = { video: v, date: pd };
    else {
      if(pd.getTime() > topNewGlobal.date.getTime()){
        topNewGlobal = { video: v, date: pd };
      }
    }
  }

  _lastTopPicks.week = topWeekGlobal && topWeekGlobal.title ? topWeekGlobal : null;
  _lastTopPicks.month = topMonthGlobal && topMonthGlobal.title ? topMonthGlobal : null;
  _lastTopPicks.total = topTotalGlobal && topTotalGlobal.title ? topTotalGlobal : null;
  _lastTopPicks.new = topNewGlobal && topNewGlobal.video ? topNewGlobal.video : null;

  document.getElementById('trendWeek').innerText = _lastTopPicks.week ? `${_lastTopPicks.week.title} — ${fmt(_lastTopPicks.week.d7)} 回` : '—';
  document.getElementById('trendMonth').innerText = _lastTopPicks.month ? `${_lastTopPicks.month.title} — ${fmt(_lastTopPicks.month.d30)} 回` : '—';
  document.getElementById('trendTotal').innerText = _lastTopPicks.total ? `${_lastTopPicks.total.title} — ${fmt(_lastTopPicks.total.latest)} 回` : '—';

  if(_lastTopPicks.new){
    const d = getPublishDate(_lastTopPicks.new) || new Date();
    const yyyyMMdd = d.toISOString().slice(0,10);
    document.getElementById('trendNew').innerText = `${_lastTopPicks.new.title} — ${yyyyMMdd}`;
  } else {
    document.getElementById('trendNew').innerText = '—';
  }

  // attach click handlers and unit-color borders/backgrounds to trend items
  function setupTrendItem(itemId, video){
    const el = document.getElementById(itemId);
    if(!el) return;
    el.style.border = '';
    el.style.cursor = '';
    el.onclick = null;

    if(video){
      const unitColor = UNIT_COLORS[video.unit] || null;
      if(unitColor){
        el.style.border = `2px solid ${unitColor}`;
        // set background as unit color mixed with white in 1:4 ratio
        el.style.background = mixWithWhiteRatio(unitColor, 4);
      } else {
        el.style.border = '1px solid rgba(15,23,42,0.04)';
        // keep default background (do not override)
        el.style.background = '';
      }
      el.style.cursor = 'pointer';
      el.onclick = function(e){
        e.stopPropagation();
        selectVideo(video);
      };
    } else {
      el.style.border = '1px solid rgba(15,23,42,0.04)';
      el.style.cursor = 'default';
      el.style.background = '';
    }
  }

  setupTrendItem('trendItemWeek', _lastTopPicks.week);
  setupTrendItem('trendItemMonth', _lastTopPicks.month);
  setupTrendItem('trendItemTotal', _lastTopPicks.total);
  setupTrendItem('trendItemNew', _lastTopPicks.new);

  // Now build the list that user sees (apply filters/search)
  const mode = sortModeEl.value;
  const q = searchEl.value.trim().toLowerCase();
  let list = DATA.slice();

  const gv = groupFilterEl.value;
  if(gv && gv !== 'all'){
    if(gv.startsWith('banner:')) list = list.filter(v=>v.banner === gv.slice(7));
    else if(gv.startsWith('unit:')) list = list.filter(v=>v.unit === gv.slice(5));
    else {
      if(scopeEl.value === 'banner') list = list.filter(v=>v.banner === gv);
      if(scopeEl.value === 'unit') list = list.filter(v=>v.unit === gv);
    }
  }

  if(q) list = list.filter(v=>{
    return (v.title||'').toLowerCase().includes(q) || (v.banner||'').toLowerCase().includes(q) || (v.unit||'').toLowerCase().includes(q);
  });

  const annotated = list.map(v=>{
    const latest = v.history && v.history.length ? (v.history[v.history.length-1].views || 0) : (v.views || 0);
    const d7 = calcDelta(v.history, 7);
    const d30 = calcDelta(v.history, 30);
    return {...v, latest, d7, d30};
  });

  if(mode === 'total') {
    annotated.sort((a,b)=>b.latest - a.latest);
  } else if(mode === 'published') {
    annotated.sort((a,b)=>{
      const da = parseISOorDateString(a.published) || (a.history && a.history.length ? new Date(a.history[a.history.length-1].datetime || a.history[a.history.length-1].date + 'T00:00:00.000Z') : null);
      const db = parseISOorDateString(b.published) || (b.history && b.history.length ? new Date(b.history[b.history.length-1].datetime || b.history[b.history.length-1].date + 'T00:00:00.000Z') : null);
      const ta = da ? da.getTime() : 0;
      const tb = db ? db.getTime() : 0;
      return tb - ta; // newest first
    });
  }

  rankListEl.innerHTML = '';
  if(annotated.length === 0){
    rankListEl.innerText = '該当する動画がありません。';
    return;
  }

  annotated.forEach((v, idx)=>{
    const li = document.createElement('div');
    li.className = 'video-item';
    li.innerHTML = `
      <div class="rank-num">${idx+1}</div>
      <img class="thumb" src="${escapeHtml(v.thumbnail)}" alt="thumb">
      <div class="meta">
        <div class="title">${escapeHtml(v.title)}</div>
        <div class="sub">
          <div class="badge">${escapeHtml(v.banner)}</div>
          <div class="badge">${escapeHtml(v.unit)}</div>
          <div style="margin-left:auto;color:var(--muted)">${fmt(v.latest)} 回</div>
          <div style="color:var(--muted);font-size:12px">▲${fmt(v.d7)} / 7d</div>
        </div>
      </div>
    `;
    // after element created, color the badges by mixing with white 1:2 and attach click handlers
    const badgeEls = li.querySelectorAll('.badge');
    if(badgeEls && badgeEls.length >= 1){
      const bannerHex = (v.banner && BANNER_COLORS[v.banner]) ? BANNER_COLORS[v.banner] : '#2563eb';
      const blended = mixWithWhite(bannerHex);
      badgeEls[0].style.backgroundColor = blended;
      badgeEls[0].style.color = '#111827';
      badgeEls[0].style.border = '1px solid rgba(15,23,42,0.04)';
      badgeEls[0].classList.add('clickable');
      // click -> jump to banner filter
      badgeEls[0].addEventListener('click', function(e){
        e.stopPropagation();
        scopeEl.value = 'all';
        buildGroupOptions();
        try { groupFilterEl.value = `banner:${v.banner}`; } catch(e){}
        renderRankList();
        rankListEl.scrollTop = 0;
      });
    }
    if(badgeEls && badgeEls.length >= 2){
      const unitHex = (v.unit && UNIT_COLORS[v.unit]) ? UNIT_COLORS[v.unit] : '#2563eb';
      const blendedU = mixWithWhite(unitHex);
      badgeEls[1].style.backgroundColor = blendedU;
      badgeEls[1].style.color = '#111827';
      badgeEls[1].style.border = '1px solid rgba(15,23,42,0.04)';
      badgeEls[1].classList.add('clickable');
      // click -> jump to unit filter
      badgeEls[1].addEventListener('click', function(e){
        e.stopPropagation();
        scopeEl.value = 'all';
        buildGroupOptions();
        try { groupFilterEl.value = `unit:${v.unit}`; } catch(e){}
        renderRankList();
        rankListEl.scrollTop = 0;
      });
    }

    li.addEventListener('click', ()=> selectVideo(v));
    rankListEl.appendChild(li);
  });
}

/* --- chart & selection --- */
let currentSelected = null;
const ctx = document.getElementById('trendChart').getContext('2d');
let chart = null;

function selectVideo(v){
  // Accept either a video object from DATA or an object that at least contains videoId.
  const vid = (v && v.videoId) ? v.videoId : (typeof v === 'string' ? v : null);
  let fresh = null;
  if(vid) fresh = DATA.find(x=>x.videoId === vid) || v;
  else fresh = v;

  currentSelected = fresh;
  if(!currentSelected) return;

  document.getElementById('selectedTitle').innerText = currentSelected.title || '（動画を選択してください）';
  // keep link only in selectedMeta to avoid duplicate banner/unit display
  document.getElementById('selectedMeta').innerHTML = `<a href="${currentSelected.url || '#'}" target="_blank" style="color:var(--accent)">${currentSelected.url ? 'YouTubeへ' : ''}</a>`;

  // show the latest API-fetched value (should be the last history entry's views)
  const lastRec = currentSelected.history && currentSelected.history.length ? currentSelected.history[currentSelected.history.length-1] : null;
  const lastViews = lastRec ? lastRec.views : (currentSelected.views || 0);
  document.getElementById('selectedViews').innerText = fmt(lastViews) + ' 回';
  document.getElementById('viewDelta7').innerText = fmt(calcDelta(currentSelected.history,7)) + ' 回';
  document.getElementById('viewDelta30').innerText = fmt(calcDelta(currentSelected.history,30)) + ' 回';
  document.getElementById('publishDate').innerText = currentSelected.published || '—';

  // Show badges (unit and banner) in the right-top stats area (replaces the old 最新再生数)
  const badgesEl = document.getElementById('selectedBadges');
  if(badgesEl){
    badgesEl.innerHTML = '';

    const bannerBadge = document.createElement('div');
    bannerBadge.className = 'badge clickable';
    bannerBadge.innerText = currentSelected.banner || '—';
    const bannerHex = (currentSelected.banner && BANNER_COLORS[currentSelected.banner]) ? BANNER_COLORS[currentSelected.banner] : '#2563eb';
    bannerBadge.style.backgroundColor = mixWithWhite(bannerHex);
    bannerBadge.style.color = '#111827';
    bannerBadge.style.border = '1px solid rgba(15,23,42,0.04)';
    // badge click -> jump to banner classification
    bannerBadge.addEventListener('click', function(e){
      e.stopPropagation();
      scopeEl.value = 'all';
      buildGroupOptions();
      try { groupFilterEl.value = `banner:${currentSelected.banner}`; } catch(e){}
      renderRankList();
      rankListEl.scrollTop = 0;
    });
    badgesEl.appendChild(bannerBadge);

    const unitBadge = document.createElement('div');
    unitBadge.className = 'badge clickable';
    unitBadge.innerText = currentSelected.unit || '—';
    const unitHex = (currentSelected.unit && UNIT_COLORS[currentSelected.unit]) ? UNIT_COLORS[currentSelected.unit] : '#2563eb';
    unitBadge.style.backgroundColor = mixWithWhite(unitHex);
    unitBadge.style.color = '#111827';
    unitBadge.style.border = '1px solid rgba(15,23,42,0.04)';
    // badge click -> jump to unit classification
    unitBadge.addEventListener('click', function(e){
      e.stopPropagation();
      scopeEl.value = 'all';
      buildGroupOptions();
      try { groupFilterEl.value = `unit:${currentSelected.unit}`; } catch(e){}
      renderRankList();
      rankListEl.scrollTop = 0;
    });
    badgesEl.appendChild(unitBadge);
  }

  // redraw chart using up-to-date history (but we will display predicted values only)
  drawChartForSelection(document.querySelector('.tab-mode.active') ? document.querySelector('.tab-mode.active').dataset.period : 'all');
}

/* --- drawChartForSelection (modified to use improved predictor) --- */
function drawChartForSelection(period){
  if(!currentSelected) return;
  const hist = currentSelected.history || [];
  if(hist.length === 0) {
    if(chart){ chart.destroy(); chart = null; }
    ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height);
    return;
  }

  // last recorded actual
  const lastRec = hist[hist.length - 1];
  const lastRecTime = lastRec.datetime ? new Date(lastRec.datetime) : (lastRec.date ? new Date(lastRec.date + 'T00:00:00.000Z') : null);
  const lastRecViews = lastRec.views || 0;

  // advanced slope estimation
  const slopeInfo = computeAdvancedSlope(hist);
  const slopePerMin = slopeInfo.slope_final; // views per minute

  const now = new Date();

  // determine start time for predictions based on period
  let startTime = null;
  if(period === '7'){
    startTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  } else if(period === '30'){
    startTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
  } else {
    // 'all' => use earliest history timestamp if available; otherwise fallback to 30 days
    const pts = preprocessHistory(hist);
    const firstRec = pts[0];
    const firstT = firstRec ? (firstRec.t ? new Date(firstRec.t) : null) : null;
    if(firstT && !isNaN(firstT.getTime())) startTime = new Date(firstT);
    else startTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
  }

  // make sure startTime is not after now
  if(startTime > now) startTime = new Date(now.getTime());

  // use floorToHalfHour(startTime) so earlier half-hour (e.g. 18:30) is included
  let t0 = floorToHalfHour(startTime);
  // If t0 ended up > now (unlikely) floor to previous half hour of now
  if(t0 > now) t0 = floorToHalfHour(now);

  const ticks = [];
  const thirtyMin = 30 * 60 * 1000;
  for(let t = new Date(t0.getTime()); t.getTime() <= now.getTime(); t = new Date(t.getTime() + thirtyMin)){
    ticks.push(new Date(t.getTime()));
    // safety maximum of 2000 ticks to avoid insane plotting
    if(ticks.length > 2000) break;
  }
  // ensure current exact time is included as last tick (if not equal to last item)
  if(ticks.length === 0 || Math.abs(ticks[ticks.length-1].getTime() - now.getTime()) > 1000){
    ticks.push(new Date(now.getTime()));
  }

  // compute predicted values: anchor from last recorded point (linear with slopePerMin)
  const labels = [];
  const data = [];
  const timesFull = [];

  for(const t of ticks){
    const deltaMin = (t.getTime() - lastRecTime.getTime()) / 60000; // can be negative if tick before lastRecTime
    let pred = Math.round(lastRecViews + slopePerMin * deltaMin);
    if(pred < 0) pred = 0;
    labels.push(formatLabelForTick(t, period));
    data.push(pred);
    timesFull.push(t.toLocaleString());
  }

  // choose color: prefer banner color if present, else unit color
  const banner = currentSelected.banner;
  let colorHex = (banner && banner !== '-' && BANNER_COLORS[banner]) ? BANNER_COLORS[banner] : (UNIT_COLORS[currentSelected.unit] || '#2563eb');
  const areaColor = hexToRgba(colorHex, 0.06);
  const lineColor = colorHex;

  if(chart){
    chart.data.labels = labels;
    chart.data.datasets[0].data = data;
    chart.data.datasets[0].backgroundColor = areaColor;
    chart.data.datasets[0].borderColor = lineColor;
    chart.data.datasets[0].timesFull = timesFull;
    chart.update('none');
  } else {
    chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [{
          label: currentSelected.title,
          data,
          tension:0.2,
          fill:true,
          backgroundColor: areaColor,
          borderColor: lineColor,
          pointRadius:3,
          // attach times array so tooltip callback can access time including clock (recorded time)
          timesFull: timesFull
        }]
      },
      options: {
        responsive:true, maintainAspectRatio:false,
        interaction: { mode: 'nearest', intersect: false },
        layout: { padding: { left: 0, right: 0, top: 0, bottom: 0 } },
        scales: {
          x: {
            display:true,
            grid:{color:'rgba(15,23,42,0.03)'},
            ticks:{ color:'#6b7c93', font: { size:10 }, autoSkip: true, maxRotation:0, minRotation:0 },
            type: 'category'
          },
          y: {
            display:true,
            grid:{color:'rgba(15,23,42,0.03)'},
            ticks:{ color:'#6b7c93', font: { size:10 }, padding: 2, callback: v => Intl.NumberFormat().format(v) },
            beginAtZero: false,
            offset: false
          }
        },
        plugins: {
          legend:{display:false},
          tooltip:{
            callbacks:{
              // show the exact datetime when the value is predicted as tooltip title (in local time)
              title: function(items){
                if(!items || !items.length) return '';
                const it = items[0];
                const ds = chart.data.datasets[it.datasetIndex];
                if(ds && Array.isArray(ds.timesFull) && ds.timesFull[it.dataIndex]) return '推定: ' + ds.timesFull[it.dataIndex];
                // fallback to label (date)
                return chart.data.labels[it.dataIndex] || '';
              },
              // show views as label, marked as 推定
              label: function(context){
                return `推定 ${Intl.NumberFormat().format(context.parsed.y)} 回`;
              }
            }
          }
        }
      }
    });
  }

  // Ensure latest API value is shown in the metric after (re)draw
  const selViews = document.getElementById('selectedViews');
  if(selViews) selViews.innerText = `${Intl.NumberFormat().format(lastRecViews)} 回`;
}

/* helper to generate concise labels (for x-axis)
   - if period spans multiple days show "YYYY-MM-DD HH:mm"
   - if single day show "HH:mm"
*/
function formatLabelForTick(date, period){
  const now = new Date();
  const daysSpan = (function(){
    if(period === '7') return 7;
    if(period === '30') return 30;
    // for 'all', approximate by realized tick spread
    return 3;
  })();
  if(daysSpan > 1){
    // show date + time
    const y = date.getFullYear();
    const m = String(date.getMonth()+1).padStart(2,'0');
    const d = String(date.getDate()).padStart(2,'0');
    const hh = String(date.getHours()).padStart(2,'0');
    const mm = String(date.getMinutes()).padStart(2,'0');
    return `${y}-${m}-${d} ${hh}:${mm}`;
  } else {
    const hh = String(date.getHours()).padStart(2,'0');
    const mm = String(date.getMinutes()).padStart(2,'0');
    return `${hh}:${mm}`;
  }
}

/* --- clicking outside the chart restores latest API value into the metric --- */
document.addEventListener('click', function(evt){
  const chartAreaEl = document.querySelector('.chart-area');
  if(!chartAreaEl) return;
  if(!chartAreaEl.contains(evt.target)){
    // restore latest value to the true latest record when clicking outside chart area
    if(currentSelected){
      const lastRec = currentSelected.history && currentSelected.history.length ? currentSelected.history[currentSelected.history.length-1] : null;
      const lastViews = lastRec ? lastRec.views : (currentSelected.views || 0);
      const selViews = document.getElementById('selectedViews');
      if(selViews) selViews.innerText = `${Intl.NumberFormat().format(lastViews)} 回`;
    }
  }
});

/* --- event binding --- */
// clear groups button
if(clearBtn) clearBtn.addEventListener('click', function(){
  scopeEl.value = 'all';
  buildGroupOptions();
  try { groupFilterEl.value = 'all'; } catch(e){}
  renderRankList();
  rankListEl.scrollTop = 0;
});

sortModeEl.addEventListener('change', renderRankList);
searchEl.addEventListener('input', renderRankList);
scopeEl.addEventListener('change', ()=>{ buildGroupOptions(); renderRankList(); });
groupFilterEl.addEventListener('change', renderRankList);

// safe binding for optional buttons
const btnAll = document.getElementById('btnAll');
if(btnAll) btnAll.addEventListener('click', ()=> { scopeEl.value='all'; buildGroupOptions(); renderRankList(); });
const btnBanner = document.getElementById('btnBanner');
if(btnBanner) btnBanner.addEventListener('click', ()=> { scopeEl.value='banner'; buildGroupOptions(); renderRankList(); });
const btnUnit = document.getElementById('btnUnit');
if(btnUnit) btnUnit.addEventListener('click', ()=> { scopeEl.value='unit'; buildGroupOptions(); renderRankList(); });

document.querySelectorAll('.tab-mode').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.tab-mode').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    drawChartForSelection(btn.dataset.period);
  });
});

/* --- default select --- */
function selectDefault(){
  if(DATA.length) {
    const sorted = DATA.slice().sort((a,b)=> {
      const la = a.history && a.history.length ? a.history[a.history.length-1].views : (a.views||0);
      const lb = b.history && b.history.length ? b.history[b.history.length-1].views : (b.views||0);
      return lb - la;
    });
    selectVideo(sorted[0]);
  }
}

/* --- initial load --- */
loadData();

// --- Auto-refresh data every 20 minutes (to match API fetch cadence)
const TWENTY_MIN = 20 * 60 * 1000;
setInterval(() => {
  // refresh file from server
  loadData();
}, TWENTY_MIN);
</script>
</body>
</html>
